// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"product-server/ent/orderhistory"
	"product-server/ent/orderrow"
	"product-server/ent/predicate"
	"product-server/ent/productinfo"
	"product-server/ent/size"
	"product-server/ent/user"
	"product-server/ent/useraddress"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeOrderHistory = "OrderHistory"
	TypeOrderRow     = "OrderRow"
	TypeProductInfo  = "ProductInfo"
	TypeSize         = "Size"
	TypeUser         = "User"
	TypeUserAddress  = "UserAddress"
)

// OrderHistoryMutation represents an operation that mutates the OrderHistory nodes in the graph.
type OrderHistoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	ordered_at           *time.Time
	user_order_number    *int32
	adduser_order_number *int32
	order_status         *string
	order_total_price    *int32
	addorder_total_price *int32
	payment_method       *string
	payment_status       *string
	payment_info         *string
	payment_key          *string
	clearedFields        map[string]struct{}
	user                 *string
	cleareduser          bool
	user_addre           *string
	cleareduser_addre    bool
	order_rows           map[int32]struct{}
	removedorder_rows    map[int32]struct{}
	clearedorder_rows    bool
	done                 bool
	oldValue             func(context.Context) (*OrderHistory, error)
	predicates           []predicate.OrderHistory
}

var _ ent.Mutation = (*OrderHistoryMutation)(nil)

// orderhistoryOption allows management of the mutation configuration using functional options.
type orderhistoryOption func(*OrderHistoryMutation)

// newOrderHistoryMutation creates new mutation for the OrderHistory entity.
func newOrderHistoryMutation(c config, op Op, opts ...orderhistoryOption) *OrderHistoryMutation {
	m := &OrderHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderHistoryID sets the ID field of the mutation.
func withOrderHistoryID(id string) orderhistoryOption {
	return func(m *OrderHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderHistory
		)
		m.oldValue = func(ctx context.Context) (*OrderHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderHistory sets the old OrderHistory of the mutation.
func withOrderHistory(node *OrderHistory) orderhistoryOption {
	return func(m *OrderHistoryMutation) {
		m.oldValue = func(context.Context) (*OrderHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderHistory entities.
func (m *OrderHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *OrderHistoryMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrderHistoryMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrderHistory entity.
// If the OrderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHistoryMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *OrderHistoryMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[orderhistory.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *OrderHistoryMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[orderhistory.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrderHistoryMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, orderhistory.FieldUserID)
}

// SetAddressID sets the "address_id" field.
func (m *OrderHistoryMutation) SetAddressID(s string) {
	m.user_addre = &s
}

// AddressID returns the value of the "address_id" field in the mutation.
func (m *OrderHistoryMutation) AddressID() (r string, exists bool) {
	v := m.user_addre
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressID returns the old "address_id" field's value of the OrderHistory entity.
// If the OrderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHistoryMutation) OldAddressID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressID: %w", err)
	}
	return oldValue.AddressID, nil
}

// ClearAddressID clears the value of the "address_id" field.
func (m *OrderHistoryMutation) ClearAddressID() {
	m.user_addre = nil
	m.clearedFields[orderhistory.FieldAddressID] = struct{}{}
}

// AddressIDCleared returns if the "address_id" field was cleared in this mutation.
func (m *OrderHistoryMutation) AddressIDCleared() bool {
	_, ok := m.clearedFields[orderhistory.FieldAddressID]
	return ok
}

// ResetAddressID resets all changes to the "address_id" field.
func (m *OrderHistoryMutation) ResetAddressID() {
	m.user_addre = nil
	delete(m.clearedFields, orderhistory.FieldAddressID)
}

// SetOrderedAt sets the "ordered_at" field.
func (m *OrderHistoryMutation) SetOrderedAt(t time.Time) {
	m.ordered_at = &t
}

// OrderedAt returns the value of the "ordered_at" field in the mutation.
func (m *OrderHistoryMutation) OrderedAt() (r time.Time, exists bool) {
	v := m.ordered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderedAt returns the old "ordered_at" field's value of the OrderHistory entity.
// If the OrderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHistoryMutation) OldOrderedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderedAt: %w", err)
	}
	return oldValue.OrderedAt, nil
}

// ResetOrderedAt resets all changes to the "ordered_at" field.
func (m *OrderHistoryMutation) ResetOrderedAt() {
	m.ordered_at = nil
}

// SetUserOrderNumber sets the "user_order_number" field.
func (m *OrderHistoryMutation) SetUserOrderNumber(i int32) {
	m.user_order_number = &i
	m.adduser_order_number = nil
}

// UserOrderNumber returns the value of the "user_order_number" field in the mutation.
func (m *OrderHistoryMutation) UserOrderNumber() (r int32, exists bool) {
	v := m.user_order_number
	if v == nil {
		return
	}
	return *v, true
}

// OldUserOrderNumber returns the old "user_order_number" field's value of the OrderHistory entity.
// If the OrderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHistoryMutation) OldUserOrderNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserOrderNumber: %w", err)
	}
	return oldValue.UserOrderNumber, nil
}

// AddUserOrderNumber adds i to the "user_order_number" field.
func (m *OrderHistoryMutation) AddUserOrderNumber(i int32) {
	if m.adduser_order_number != nil {
		*m.adduser_order_number += i
	} else {
		m.adduser_order_number = &i
	}
}

// AddedUserOrderNumber returns the value that was added to the "user_order_number" field in this mutation.
func (m *OrderHistoryMutation) AddedUserOrderNumber() (r int32, exists bool) {
	v := m.adduser_order_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserOrderNumber resets all changes to the "user_order_number" field.
func (m *OrderHistoryMutation) ResetUserOrderNumber() {
	m.user_order_number = nil
	m.adduser_order_number = nil
}

// SetOrderStatus sets the "order_status" field.
func (m *OrderHistoryMutation) SetOrderStatus(s string) {
	m.order_status = &s
}

// OrderStatus returns the value of the "order_status" field in the mutation.
func (m *OrderHistoryMutation) OrderStatus() (r string, exists bool) {
	v := m.order_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderStatus returns the old "order_status" field's value of the OrderHistory entity.
// If the OrderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHistoryMutation) OldOrderStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderStatus: %w", err)
	}
	return oldValue.OrderStatus, nil
}

// ResetOrderStatus resets all changes to the "order_status" field.
func (m *OrderHistoryMutation) ResetOrderStatus() {
	m.order_status = nil
}

// SetOrderTotalPrice sets the "order_total_price" field.
func (m *OrderHistoryMutation) SetOrderTotalPrice(i int32) {
	m.order_total_price = &i
	m.addorder_total_price = nil
}

// OrderTotalPrice returns the value of the "order_total_price" field in the mutation.
func (m *OrderHistoryMutation) OrderTotalPrice() (r int32, exists bool) {
	v := m.order_total_price
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderTotalPrice returns the old "order_total_price" field's value of the OrderHistory entity.
// If the OrderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHistoryMutation) OldOrderTotalPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderTotalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderTotalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderTotalPrice: %w", err)
	}
	return oldValue.OrderTotalPrice, nil
}

// AddOrderTotalPrice adds i to the "order_total_price" field.
func (m *OrderHistoryMutation) AddOrderTotalPrice(i int32) {
	if m.addorder_total_price != nil {
		*m.addorder_total_price += i
	} else {
		m.addorder_total_price = &i
	}
}

// AddedOrderTotalPrice returns the value that was added to the "order_total_price" field in this mutation.
func (m *OrderHistoryMutation) AddedOrderTotalPrice() (r int32, exists bool) {
	v := m.addorder_total_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderTotalPrice resets all changes to the "order_total_price" field.
func (m *OrderHistoryMutation) ResetOrderTotalPrice() {
	m.order_total_price = nil
	m.addorder_total_price = nil
}

// SetPaymentMethod sets the "payment_method" field.
func (m *OrderHistoryMutation) SetPaymentMethod(s string) {
	m.payment_method = &s
}

// PaymentMethod returns the value of the "payment_method" field in the mutation.
func (m *OrderHistoryMutation) PaymentMethod() (r string, exists bool) {
	v := m.payment_method
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentMethod returns the old "payment_method" field's value of the OrderHistory entity.
// If the OrderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHistoryMutation) OldPaymentMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentMethod: %w", err)
	}
	return oldValue.PaymentMethod, nil
}

// ResetPaymentMethod resets all changes to the "payment_method" field.
func (m *OrderHistoryMutation) ResetPaymentMethod() {
	m.payment_method = nil
}

// SetPaymentStatus sets the "payment_status" field.
func (m *OrderHistoryMutation) SetPaymentStatus(s string) {
	m.payment_status = &s
}

// PaymentStatus returns the value of the "payment_status" field in the mutation.
func (m *OrderHistoryMutation) PaymentStatus() (r string, exists bool) {
	v := m.payment_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentStatus returns the old "payment_status" field's value of the OrderHistory entity.
// If the OrderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHistoryMutation) OldPaymentStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentStatus: %w", err)
	}
	return oldValue.PaymentStatus, nil
}

// ResetPaymentStatus resets all changes to the "payment_status" field.
func (m *OrderHistoryMutation) ResetPaymentStatus() {
	m.payment_status = nil
}

// SetPaymentInfo sets the "payment_info" field.
func (m *OrderHistoryMutation) SetPaymentInfo(s string) {
	m.payment_info = &s
}

// PaymentInfo returns the value of the "payment_info" field in the mutation.
func (m *OrderHistoryMutation) PaymentInfo() (r string, exists bool) {
	v := m.payment_info
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentInfo returns the old "payment_info" field's value of the OrderHistory entity.
// If the OrderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHistoryMutation) OldPaymentInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentInfo: %w", err)
	}
	return oldValue.PaymentInfo, nil
}

// ClearPaymentInfo clears the value of the "payment_info" field.
func (m *OrderHistoryMutation) ClearPaymentInfo() {
	m.payment_info = nil
	m.clearedFields[orderhistory.FieldPaymentInfo] = struct{}{}
}

// PaymentInfoCleared returns if the "payment_info" field was cleared in this mutation.
func (m *OrderHistoryMutation) PaymentInfoCleared() bool {
	_, ok := m.clearedFields[orderhistory.FieldPaymentInfo]
	return ok
}

// ResetPaymentInfo resets all changes to the "payment_info" field.
func (m *OrderHistoryMutation) ResetPaymentInfo() {
	m.payment_info = nil
	delete(m.clearedFields, orderhistory.FieldPaymentInfo)
}

// SetPaymentKey sets the "payment_key" field.
func (m *OrderHistoryMutation) SetPaymentKey(s string) {
	m.payment_key = &s
}

// PaymentKey returns the value of the "payment_key" field in the mutation.
func (m *OrderHistoryMutation) PaymentKey() (r string, exists bool) {
	v := m.payment_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentKey returns the old "payment_key" field's value of the OrderHistory entity.
// If the OrderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHistoryMutation) OldPaymentKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentKey: %w", err)
	}
	return oldValue.PaymentKey, nil
}

// ResetPaymentKey resets all changes to the "payment_key" field.
func (m *OrderHistoryMutation) ResetPaymentKey() {
	m.payment_key = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrderHistoryMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[orderhistory.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrderHistoryMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrderHistoryMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrderHistoryMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetUserAddreID sets the "user_addre" edge to the UserAddress entity by id.
func (m *OrderHistoryMutation) SetUserAddreID(id string) {
	m.user_addre = &id
}

// ClearUserAddre clears the "user_addre" edge to the UserAddress entity.
func (m *OrderHistoryMutation) ClearUserAddre() {
	m.cleareduser_addre = true
	m.clearedFields[orderhistory.FieldAddressID] = struct{}{}
}

// UserAddreCleared reports if the "user_addre" edge to the UserAddress entity was cleared.
func (m *OrderHistoryMutation) UserAddreCleared() bool {
	return m.AddressIDCleared() || m.cleareduser_addre
}

// UserAddreID returns the "user_addre" edge ID in the mutation.
func (m *OrderHistoryMutation) UserAddreID() (id string, exists bool) {
	if m.user_addre != nil {
		return *m.user_addre, true
	}
	return
}

// UserAddreIDs returns the "user_addre" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserAddreID instead. It exists only for internal usage by the builders.
func (m *OrderHistoryMutation) UserAddreIDs() (ids []string) {
	if id := m.user_addre; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserAddre resets all changes to the "user_addre" edge.
func (m *OrderHistoryMutation) ResetUserAddre() {
	m.user_addre = nil
	m.cleareduser_addre = false
}

// AddOrderRowIDs adds the "order_rows" edge to the OrderRow entity by ids.
func (m *OrderHistoryMutation) AddOrderRowIDs(ids ...int32) {
	if m.order_rows == nil {
		m.order_rows = make(map[int32]struct{})
	}
	for i := range ids {
		m.order_rows[ids[i]] = struct{}{}
	}
}

// ClearOrderRows clears the "order_rows" edge to the OrderRow entity.
func (m *OrderHistoryMutation) ClearOrderRows() {
	m.clearedorder_rows = true
}

// OrderRowsCleared reports if the "order_rows" edge to the OrderRow entity was cleared.
func (m *OrderHistoryMutation) OrderRowsCleared() bool {
	return m.clearedorder_rows
}

// RemoveOrderRowIDs removes the "order_rows" edge to the OrderRow entity by IDs.
func (m *OrderHistoryMutation) RemoveOrderRowIDs(ids ...int32) {
	if m.removedorder_rows == nil {
		m.removedorder_rows = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.order_rows, ids[i])
		m.removedorder_rows[ids[i]] = struct{}{}
	}
}

// RemovedOrderRows returns the removed IDs of the "order_rows" edge to the OrderRow entity.
func (m *OrderHistoryMutation) RemovedOrderRowsIDs() (ids []int32) {
	for id := range m.removedorder_rows {
		ids = append(ids, id)
	}
	return
}

// OrderRowsIDs returns the "order_rows" edge IDs in the mutation.
func (m *OrderHistoryMutation) OrderRowsIDs() (ids []int32) {
	for id := range m.order_rows {
		ids = append(ids, id)
	}
	return
}

// ResetOrderRows resets all changes to the "order_rows" edge.
func (m *OrderHistoryMutation) ResetOrderRows() {
	m.order_rows = nil
	m.clearedorder_rows = false
	m.removedorder_rows = nil
}

// Where appends a list predicates to the OrderHistoryMutation builder.
func (m *OrderHistoryMutation) Where(ps ...predicate.OrderHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderHistory).
func (m *OrderHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderHistoryMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.user != nil {
		fields = append(fields, orderhistory.FieldUserID)
	}
	if m.user_addre != nil {
		fields = append(fields, orderhistory.FieldAddressID)
	}
	if m.ordered_at != nil {
		fields = append(fields, orderhistory.FieldOrderedAt)
	}
	if m.user_order_number != nil {
		fields = append(fields, orderhistory.FieldUserOrderNumber)
	}
	if m.order_status != nil {
		fields = append(fields, orderhistory.FieldOrderStatus)
	}
	if m.order_total_price != nil {
		fields = append(fields, orderhistory.FieldOrderTotalPrice)
	}
	if m.payment_method != nil {
		fields = append(fields, orderhistory.FieldPaymentMethod)
	}
	if m.payment_status != nil {
		fields = append(fields, orderhistory.FieldPaymentStatus)
	}
	if m.payment_info != nil {
		fields = append(fields, orderhistory.FieldPaymentInfo)
	}
	if m.payment_key != nil {
		fields = append(fields, orderhistory.FieldPaymentKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderhistory.FieldUserID:
		return m.UserID()
	case orderhistory.FieldAddressID:
		return m.AddressID()
	case orderhistory.FieldOrderedAt:
		return m.OrderedAt()
	case orderhistory.FieldUserOrderNumber:
		return m.UserOrderNumber()
	case orderhistory.FieldOrderStatus:
		return m.OrderStatus()
	case orderhistory.FieldOrderTotalPrice:
		return m.OrderTotalPrice()
	case orderhistory.FieldPaymentMethod:
		return m.PaymentMethod()
	case orderhistory.FieldPaymentStatus:
		return m.PaymentStatus()
	case orderhistory.FieldPaymentInfo:
		return m.PaymentInfo()
	case orderhistory.FieldPaymentKey:
		return m.PaymentKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderhistory.FieldUserID:
		return m.OldUserID(ctx)
	case orderhistory.FieldAddressID:
		return m.OldAddressID(ctx)
	case orderhistory.FieldOrderedAt:
		return m.OldOrderedAt(ctx)
	case orderhistory.FieldUserOrderNumber:
		return m.OldUserOrderNumber(ctx)
	case orderhistory.FieldOrderStatus:
		return m.OldOrderStatus(ctx)
	case orderhistory.FieldOrderTotalPrice:
		return m.OldOrderTotalPrice(ctx)
	case orderhistory.FieldPaymentMethod:
		return m.OldPaymentMethod(ctx)
	case orderhistory.FieldPaymentStatus:
		return m.OldPaymentStatus(ctx)
	case orderhistory.FieldPaymentInfo:
		return m.OldPaymentInfo(ctx)
	case orderhistory.FieldPaymentKey:
		return m.OldPaymentKey(ctx)
	}
	return nil, fmt.Errorf("unknown OrderHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderhistory.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case orderhistory.FieldAddressID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressID(v)
		return nil
	case orderhistory.FieldOrderedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderedAt(v)
		return nil
	case orderhistory.FieldUserOrderNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserOrderNumber(v)
		return nil
	case orderhistory.FieldOrderStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderStatus(v)
		return nil
	case orderhistory.FieldOrderTotalPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderTotalPrice(v)
		return nil
	case orderhistory.FieldPaymentMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentMethod(v)
		return nil
	case orderhistory.FieldPaymentStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentStatus(v)
		return nil
	case orderhistory.FieldPaymentInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentInfo(v)
		return nil
	case orderhistory.FieldPaymentKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentKey(v)
		return nil
	}
	return fmt.Errorf("unknown OrderHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderHistoryMutation) AddedFields() []string {
	var fields []string
	if m.adduser_order_number != nil {
		fields = append(fields, orderhistory.FieldUserOrderNumber)
	}
	if m.addorder_total_price != nil {
		fields = append(fields, orderhistory.FieldOrderTotalPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderhistory.FieldUserOrderNumber:
		return m.AddedUserOrderNumber()
	case orderhistory.FieldOrderTotalPrice:
		return m.AddedOrderTotalPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderhistory.FieldUserOrderNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserOrderNumber(v)
		return nil
	case orderhistory.FieldOrderTotalPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderTotalPrice(v)
		return nil
	}
	return fmt.Errorf("unknown OrderHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderhistory.FieldUserID) {
		fields = append(fields, orderhistory.FieldUserID)
	}
	if m.FieldCleared(orderhistory.FieldAddressID) {
		fields = append(fields, orderhistory.FieldAddressID)
	}
	if m.FieldCleared(orderhistory.FieldPaymentInfo) {
		fields = append(fields, orderhistory.FieldPaymentInfo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderHistoryMutation) ClearField(name string) error {
	switch name {
	case orderhistory.FieldUserID:
		m.ClearUserID()
		return nil
	case orderhistory.FieldAddressID:
		m.ClearAddressID()
		return nil
	case orderhistory.FieldPaymentInfo:
		m.ClearPaymentInfo()
		return nil
	}
	return fmt.Errorf("unknown OrderHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderHistoryMutation) ResetField(name string) error {
	switch name {
	case orderhistory.FieldUserID:
		m.ResetUserID()
		return nil
	case orderhistory.FieldAddressID:
		m.ResetAddressID()
		return nil
	case orderhistory.FieldOrderedAt:
		m.ResetOrderedAt()
		return nil
	case orderhistory.FieldUserOrderNumber:
		m.ResetUserOrderNumber()
		return nil
	case orderhistory.FieldOrderStatus:
		m.ResetOrderStatus()
		return nil
	case orderhistory.FieldOrderTotalPrice:
		m.ResetOrderTotalPrice()
		return nil
	case orderhistory.FieldPaymentMethod:
		m.ResetPaymentMethod()
		return nil
	case orderhistory.FieldPaymentStatus:
		m.ResetPaymentStatus()
		return nil
	case orderhistory.FieldPaymentInfo:
		m.ResetPaymentInfo()
		return nil
	case orderhistory.FieldPaymentKey:
		m.ResetPaymentKey()
		return nil
	}
	return fmt.Errorf("unknown OrderHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, orderhistory.EdgeUser)
	}
	if m.user_addre != nil {
		edges = append(edges, orderhistory.EdgeUserAddre)
	}
	if m.order_rows != nil {
		edges = append(edges, orderhistory.EdgeOrderRows)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderhistory.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case orderhistory.EdgeUserAddre:
		if id := m.user_addre; id != nil {
			return []ent.Value{*id}
		}
	case orderhistory.EdgeOrderRows:
		ids := make([]ent.Value, 0, len(m.order_rows))
		for id := range m.order_rows {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedorder_rows != nil {
		edges = append(edges, orderhistory.EdgeOrderRows)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderHistoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orderhistory.EdgeOrderRows:
		ids := make([]ent.Value, 0, len(m.removedorder_rows))
		for id := range m.removedorder_rows {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, orderhistory.EdgeUser)
	}
	if m.cleareduser_addre {
		edges = append(edges, orderhistory.EdgeUserAddre)
	}
	if m.clearedorder_rows {
		edges = append(edges, orderhistory.EdgeOrderRows)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case orderhistory.EdgeUser:
		return m.cleareduser
	case orderhistory.EdgeUserAddre:
		return m.cleareduser_addre
	case orderhistory.EdgeOrderRows:
		return m.clearedorder_rows
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderHistoryMutation) ClearEdge(name string) error {
	switch name {
	case orderhistory.EdgeUser:
		m.ClearUser()
		return nil
	case orderhistory.EdgeUserAddre:
		m.ClearUserAddre()
		return nil
	}
	return fmt.Errorf("unknown OrderHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderHistoryMutation) ResetEdge(name string) error {
	switch name {
	case orderhistory.EdgeUser:
		m.ResetUser()
		return nil
	case orderhistory.EdgeUserAddre:
		m.ResetUserAddre()
		return nil
	case orderhistory.EdgeOrderRows:
		m.ResetOrderRows()
		return nil
	}
	return fmt.Errorf("unknown OrderHistory edge %s", name)
}

// OrderRowMutation represents an operation that mutates the OrderRow nodes in the graph.
type OrderRowMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int32
	size                 *string
	quantity             *int32
	addquantity          *int32
	delivery_status      *string
	delivery_company     *string
	delivery_number      *string
	clearedFields        map[string]struct{}
	order_history        *string
	clearedorder_history bool
	product_info         *int32
	clearedproduct_info  bool
	done                 bool
	oldValue             func(context.Context) (*OrderRow, error)
	predicates           []predicate.OrderRow
}

var _ ent.Mutation = (*OrderRowMutation)(nil)

// orderrowOption allows management of the mutation configuration using functional options.
type orderrowOption func(*OrderRowMutation)

// newOrderRowMutation creates new mutation for the OrderRow entity.
func newOrderRowMutation(c config, op Op, opts ...orderrowOption) *OrderRowMutation {
	m := &OrderRowMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderRow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderRowID sets the ID field of the mutation.
func withOrderRowID(id int32) orderrowOption {
	return func(m *OrderRowMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderRow
		)
		m.oldValue = func(ctx context.Context) (*OrderRow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderRow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderRow sets the old OrderRow of the mutation.
func withOrderRow(node *OrderRow) orderrowOption {
	return func(m *OrderRowMutation) {
		m.oldValue = func(context.Context) (*OrderRow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderRowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderRowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderRow entities.
func (m *OrderRowMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderRowMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderRowMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderRow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderID sets the "order_id" field.
func (m *OrderRowMutation) SetOrderID(s string) {
	m.order_history = &s
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderRowMutation) OrderID() (r string, exists bool) {
	v := m.order_history
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderRow entity.
// If the OrderRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRowMutation) OldOrderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderRowMutation) ClearOrderID() {
	m.order_history = nil
	m.clearedFields[orderrow.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderRowMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderrow.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderRowMutation) ResetOrderID() {
	m.order_history = nil
	delete(m.clearedFields, orderrow.FieldOrderID)
}

// SetSku sets the "sku" field.
func (m *OrderRowMutation) SetSku(i int32) {
	m.product_info = &i
}

// Sku returns the value of the "sku" field in the mutation.
func (m *OrderRowMutation) Sku() (r int32, exists bool) {
	v := m.product_info
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the OrderRow entity.
// If the OrderRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRowMutation) OldSku(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ClearSku clears the value of the "sku" field.
func (m *OrderRowMutation) ClearSku() {
	m.product_info = nil
	m.clearedFields[orderrow.FieldSku] = struct{}{}
}

// SkuCleared returns if the "sku" field was cleared in this mutation.
func (m *OrderRowMutation) SkuCleared() bool {
	_, ok := m.clearedFields[orderrow.FieldSku]
	return ok
}

// ResetSku resets all changes to the "sku" field.
func (m *OrderRowMutation) ResetSku() {
	m.product_info = nil
	delete(m.clearedFields, orderrow.FieldSku)
}

// SetSize sets the "size" field.
func (m *OrderRowMutation) SetSize(s string) {
	m.size = &s
}

// Size returns the value of the "size" field in the mutation.
func (m *OrderRowMutation) Size() (r string, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the OrderRow entity.
// If the OrderRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRowMutation) OldSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// ResetSize resets all changes to the "size" field.
func (m *OrderRowMutation) ResetSize() {
	m.size = nil
}

// SetQuantity sets the "quantity" field.
func (m *OrderRowMutation) SetQuantity(i int32) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *OrderRowMutation) Quantity() (r int32, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the OrderRow entity.
// If the OrderRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRowMutation) OldQuantity(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *OrderRowMutation) AddQuantity(i int32) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *OrderRowMutation) AddedQuantity() (r int32, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *OrderRowMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetDeliveryStatus sets the "delivery_status" field.
func (m *OrderRowMutation) SetDeliveryStatus(s string) {
	m.delivery_status = &s
}

// DeliveryStatus returns the value of the "delivery_status" field in the mutation.
func (m *OrderRowMutation) DeliveryStatus() (r string, exists bool) {
	v := m.delivery_status
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryStatus returns the old "delivery_status" field's value of the OrderRow entity.
// If the OrderRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRowMutation) OldDeliveryStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryStatus: %w", err)
	}
	return oldValue.DeliveryStatus, nil
}

// ResetDeliveryStatus resets all changes to the "delivery_status" field.
func (m *OrderRowMutation) ResetDeliveryStatus() {
	m.delivery_status = nil
}

// SetDeliveryCompany sets the "delivery_company" field.
func (m *OrderRowMutation) SetDeliveryCompany(s string) {
	m.delivery_company = &s
}

// DeliveryCompany returns the value of the "delivery_company" field in the mutation.
func (m *OrderRowMutation) DeliveryCompany() (r string, exists bool) {
	v := m.delivery_company
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryCompany returns the old "delivery_company" field's value of the OrderRow entity.
// If the OrderRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRowMutation) OldDeliveryCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryCompany: %w", err)
	}
	return oldValue.DeliveryCompany, nil
}

// ClearDeliveryCompany clears the value of the "delivery_company" field.
func (m *OrderRowMutation) ClearDeliveryCompany() {
	m.delivery_company = nil
	m.clearedFields[orderrow.FieldDeliveryCompany] = struct{}{}
}

// DeliveryCompanyCleared returns if the "delivery_company" field was cleared in this mutation.
func (m *OrderRowMutation) DeliveryCompanyCleared() bool {
	_, ok := m.clearedFields[orderrow.FieldDeliveryCompany]
	return ok
}

// ResetDeliveryCompany resets all changes to the "delivery_company" field.
func (m *OrderRowMutation) ResetDeliveryCompany() {
	m.delivery_company = nil
	delete(m.clearedFields, orderrow.FieldDeliveryCompany)
}

// SetDeliveryNumber sets the "delivery_number" field.
func (m *OrderRowMutation) SetDeliveryNumber(s string) {
	m.delivery_number = &s
}

// DeliveryNumber returns the value of the "delivery_number" field in the mutation.
func (m *OrderRowMutation) DeliveryNumber() (r string, exists bool) {
	v := m.delivery_number
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryNumber returns the old "delivery_number" field's value of the OrderRow entity.
// If the OrderRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRowMutation) OldDeliveryNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryNumber: %w", err)
	}
	return oldValue.DeliveryNumber, nil
}

// ClearDeliveryNumber clears the value of the "delivery_number" field.
func (m *OrderRowMutation) ClearDeliveryNumber() {
	m.delivery_number = nil
	m.clearedFields[orderrow.FieldDeliveryNumber] = struct{}{}
}

// DeliveryNumberCleared returns if the "delivery_number" field was cleared in this mutation.
func (m *OrderRowMutation) DeliveryNumberCleared() bool {
	_, ok := m.clearedFields[orderrow.FieldDeliveryNumber]
	return ok
}

// ResetDeliveryNumber resets all changes to the "delivery_number" field.
func (m *OrderRowMutation) ResetDeliveryNumber() {
	m.delivery_number = nil
	delete(m.clearedFields, orderrow.FieldDeliveryNumber)
}

// SetOrderHistoryID sets the "order_history" edge to the OrderHistory entity by id.
func (m *OrderRowMutation) SetOrderHistoryID(id string) {
	m.order_history = &id
}

// ClearOrderHistory clears the "order_history" edge to the OrderHistory entity.
func (m *OrderRowMutation) ClearOrderHistory() {
	m.clearedorder_history = true
	m.clearedFields[orderrow.FieldOrderID] = struct{}{}
}

// OrderHistoryCleared reports if the "order_history" edge to the OrderHistory entity was cleared.
func (m *OrderRowMutation) OrderHistoryCleared() bool {
	return m.OrderIDCleared() || m.clearedorder_history
}

// OrderHistoryID returns the "order_history" edge ID in the mutation.
func (m *OrderRowMutation) OrderHistoryID() (id string, exists bool) {
	if m.order_history != nil {
		return *m.order_history, true
	}
	return
}

// OrderHistoryIDs returns the "order_history" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderHistoryID instead. It exists only for internal usage by the builders.
func (m *OrderRowMutation) OrderHistoryIDs() (ids []string) {
	if id := m.order_history; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderHistory resets all changes to the "order_history" edge.
func (m *OrderRowMutation) ResetOrderHistory() {
	m.order_history = nil
	m.clearedorder_history = false
}

// SetProductInfoID sets the "product_info" edge to the ProductInfo entity by id.
func (m *OrderRowMutation) SetProductInfoID(id int32) {
	m.product_info = &id
}

// ClearProductInfo clears the "product_info" edge to the ProductInfo entity.
func (m *OrderRowMutation) ClearProductInfo() {
	m.clearedproduct_info = true
	m.clearedFields[orderrow.FieldSku] = struct{}{}
}

// ProductInfoCleared reports if the "product_info" edge to the ProductInfo entity was cleared.
func (m *OrderRowMutation) ProductInfoCleared() bool {
	return m.SkuCleared() || m.clearedproduct_info
}

// ProductInfoID returns the "product_info" edge ID in the mutation.
func (m *OrderRowMutation) ProductInfoID() (id int32, exists bool) {
	if m.product_info != nil {
		return *m.product_info, true
	}
	return
}

// ProductInfoIDs returns the "product_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductInfoID instead. It exists only for internal usage by the builders.
func (m *OrderRowMutation) ProductInfoIDs() (ids []int32) {
	if id := m.product_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductInfo resets all changes to the "product_info" edge.
func (m *OrderRowMutation) ResetProductInfo() {
	m.product_info = nil
	m.clearedproduct_info = false
}

// Where appends a list predicates to the OrderRowMutation builder.
func (m *OrderRowMutation) Where(ps ...predicate.OrderRow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderRowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderRowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderRow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderRowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderRowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderRow).
func (m *OrderRowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderRowMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.order_history != nil {
		fields = append(fields, orderrow.FieldOrderID)
	}
	if m.product_info != nil {
		fields = append(fields, orderrow.FieldSku)
	}
	if m.size != nil {
		fields = append(fields, orderrow.FieldSize)
	}
	if m.quantity != nil {
		fields = append(fields, orderrow.FieldQuantity)
	}
	if m.delivery_status != nil {
		fields = append(fields, orderrow.FieldDeliveryStatus)
	}
	if m.delivery_company != nil {
		fields = append(fields, orderrow.FieldDeliveryCompany)
	}
	if m.delivery_number != nil {
		fields = append(fields, orderrow.FieldDeliveryNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderRowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderrow.FieldOrderID:
		return m.OrderID()
	case orderrow.FieldSku:
		return m.Sku()
	case orderrow.FieldSize:
		return m.Size()
	case orderrow.FieldQuantity:
		return m.Quantity()
	case orderrow.FieldDeliveryStatus:
		return m.DeliveryStatus()
	case orderrow.FieldDeliveryCompany:
		return m.DeliveryCompany()
	case orderrow.FieldDeliveryNumber:
		return m.DeliveryNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderRowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderrow.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderrow.FieldSku:
		return m.OldSku(ctx)
	case orderrow.FieldSize:
		return m.OldSize(ctx)
	case orderrow.FieldQuantity:
		return m.OldQuantity(ctx)
	case orderrow.FieldDeliveryStatus:
		return m.OldDeliveryStatus(ctx)
	case orderrow.FieldDeliveryCompany:
		return m.OldDeliveryCompany(ctx)
	case orderrow.FieldDeliveryNumber:
		return m.OldDeliveryNumber(ctx)
	}
	return nil, fmt.Errorf("unknown OrderRow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderRowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderrow.FieldOrderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderrow.FieldSku:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case orderrow.FieldSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case orderrow.FieldQuantity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case orderrow.FieldDeliveryStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryStatus(v)
		return nil
	case orderrow.FieldDeliveryCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryCompany(v)
		return nil
	case orderrow.FieldDeliveryNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryNumber(v)
		return nil
	}
	return fmt.Errorf("unknown OrderRow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderRowMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, orderrow.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderRowMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderrow.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderRowMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderrow.FieldQuantity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown OrderRow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderRowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderrow.FieldOrderID) {
		fields = append(fields, orderrow.FieldOrderID)
	}
	if m.FieldCleared(orderrow.FieldSku) {
		fields = append(fields, orderrow.FieldSku)
	}
	if m.FieldCleared(orderrow.FieldDeliveryCompany) {
		fields = append(fields, orderrow.FieldDeliveryCompany)
	}
	if m.FieldCleared(orderrow.FieldDeliveryNumber) {
		fields = append(fields, orderrow.FieldDeliveryNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderRowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderRowMutation) ClearField(name string) error {
	switch name {
	case orderrow.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderrow.FieldSku:
		m.ClearSku()
		return nil
	case orderrow.FieldDeliveryCompany:
		m.ClearDeliveryCompany()
		return nil
	case orderrow.FieldDeliveryNumber:
		m.ClearDeliveryNumber()
		return nil
	}
	return fmt.Errorf("unknown OrderRow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderRowMutation) ResetField(name string) error {
	switch name {
	case orderrow.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderrow.FieldSku:
		m.ResetSku()
		return nil
	case orderrow.FieldSize:
		m.ResetSize()
		return nil
	case orderrow.FieldQuantity:
		m.ResetQuantity()
		return nil
	case orderrow.FieldDeliveryStatus:
		m.ResetDeliveryStatus()
		return nil
	case orderrow.FieldDeliveryCompany:
		m.ResetDeliveryCompany()
		return nil
	case orderrow.FieldDeliveryNumber:
		m.ResetDeliveryNumber()
		return nil
	}
	return fmt.Errorf("unknown OrderRow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderRowMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.order_history != nil {
		edges = append(edges, orderrow.EdgeOrderHistory)
	}
	if m.product_info != nil {
		edges = append(edges, orderrow.EdgeProductInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderRowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderrow.EdgeOrderHistory:
		if id := m.order_history; id != nil {
			return []ent.Value{*id}
		}
	case orderrow.EdgeProductInfo:
		if id := m.product_info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderRowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderRowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderRowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorder_history {
		edges = append(edges, orderrow.EdgeOrderHistory)
	}
	if m.clearedproduct_info {
		edges = append(edges, orderrow.EdgeProductInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderRowMutation) EdgeCleared(name string) bool {
	switch name {
	case orderrow.EdgeOrderHistory:
		return m.clearedorder_history
	case orderrow.EdgeProductInfo:
		return m.clearedproduct_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderRowMutation) ClearEdge(name string) error {
	switch name {
	case orderrow.EdgeOrderHistory:
		m.ClearOrderHistory()
		return nil
	case orderrow.EdgeProductInfo:
		m.ClearProductInfo()
		return nil
	}
	return fmt.Errorf("unknown OrderRow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderRowMutation) ResetEdge(name string) error {
	switch name {
	case orderrow.EdgeOrderHistory:
		m.ResetOrderHistory()
		return nil
	case orderrow.EdgeProductInfo:
		m.ResetProductInfo()
		return nil
	}
	return fmt.Errorf("unknown OrderRow edge %s", name)
}

// ProductInfoMutation represents an operation that mutates the ProductInfo nodes in the graph.
type ProductInfoMutation struct {
	config
	op                Op
	typ               string
	id                *int32
	brand             *string
	product_name      *string
	product_id        *string
	shipping_fee      *int32
	addshipping_fee   *int32
	price             *int32
	addprice          *int32
	intl              *bool
	search_info       *string
	color             *string
	category          *string
	category_spec     *string
	img_type          *string
	price_desc_cursor *string
	price_asc_cursor  *string
	deploy            *int32
	adddeploy         *int32
	kor_product_name  *string
	kor_brand         *string
	clearedFields     map[string]struct{}
	order_rows        map[int32]struct{}
	removedorder_rows map[int32]struct{}
	clearedorder_rows bool
	sizes             map[int32]struct{}
	removedsizes      map[int32]struct{}
	clearedsizes      bool
	done              bool
	oldValue          func(context.Context) (*ProductInfo, error)
	predicates        []predicate.ProductInfo
}

var _ ent.Mutation = (*ProductInfoMutation)(nil)

// productinfoOption allows management of the mutation configuration using functional options.
type productinfoOption func(*ProductInfoMutation)

// newProductInfoMutation creates new mutation for the ProductInfo entity.
func newProductInfoMutation(c config, op Op, opts ...productinfoOption) *ProductInfoMutation {
	m := &ProductInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeProductInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductInfoID sets the ID field of the mutation.
func withProductInfoID(id int32) productinfoOption {
	return func(m *ProductInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductInfo
		)
		m.oldValue = func(ctx context.Context) (*ProductInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductInfo sets the old ProductInfo of the mutation.
func withProductInfo(node *ProductInfo) productinfoOption {
	return func(m *ProductInfoMutation) {
		m.oldValue = func(context.Context) (*ProductInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductInfo entities.
func (m *ProductInfoMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductInfoMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductInfoMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBrand sets the "brand" field.
func (m *ProductInfoMutation) SetBrand(s string) {
	m.brand = &s
}

// Brand returns the value of the "brand" field in the mutation.
func (m *ProductInfoMutation) Brand() (r string, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrand returns the old "brand" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldBrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrand: %w", err)
	}
	return oldValue.Brand, nil
}

// ClearBrand clears the value of the "brand" field.
func (m *ProductInfoMutation) ClearBrand() {
	m.brand = nil
	m.clearedFields[productinfo.FieldBrand] = struct{}{}
}

// BrandCleared returns if the "brand" field was cleared in this mutation.
func (m *ProductInfoMutation) BrandCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldBrand]
	return ok
}

// ResetBrand resets all changes to the "brand" field.
func (m *ProductInfoMutation) ResetBrand() {
	m.brand = nil
	delete(m.clearedFields, productinfo.FieldBrand)
}

// SetProductName sets the "product_name" field.
func (m *ProductInfoMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the value of the "product_name" field in the mutation.
func (m *ProductInfoMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "product_name" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ClearProductName clears the value of the "product_name" field.
func (m *ProductInfoMutation) ClearProductName() {
	m.product_name = nil
	m.clearedFields[productinfo.FieldProductName] = struct{}{}
}

// ProductNameCleared returns if the "product_name" field was cleared in this mutation.
func (m *ProductInfoMutation) ProductNameCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldProductName]
	return ok
}

// ResetProductName resets all changes to the "product_name" field.
func (m *ProductInfoMutation) ResetProductName() {
	m.product_name = nil
	delete(m.clearedFields, productinfo.FieldProductName)
}

// SetProductID sets the "product_id" field.
func (m *ProductInfoMutation) SetProductID(s string) {
	m.product_id = &s
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductInfoMutation) ProductID() (r string, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldProductID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ClearProductID clears the value of the "product_id" field.
func (m *ProductInfoMutation) ClearProductID() {
	m.product_id = nil
	m.clearedFields[productinfo.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ProductInfoMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductInfoMutation) ResetProductID() {
	m.product_id = nil
	delete(m.clearedFields, productinfo.FieldProductID)
}

// SetShippingFee sets the "shipping_fee" field.
func (m *ProductInfoMutation) SetShippingFee(i int32) {
	m.shipping_fee = &i
	m.addshipping_fee = nil
}

// ShippingFee returns the value of the "shipping_fee" field in the mutation.
func (m *ProductInfoMutation) ShippingFee() (r int32, exists bool) {
	v := m.shipping_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingFee returns the old "shipping_fee" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldShippingFee(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingFee: %w", err)
	}
	return oldValue.ShippingFee, nil
}

// AddShippingFee adds i to the "shipping_fee" field.
func (m *ProductInfoMutation) AddShippingFee(i int32) {
	if m.addshipping_fee != nil {
		*m.addshipping_fee += i
	} else {
		m.addshipping_fee = &i
	}
}

// AddedShippingFee returns the value that was added to the "shipping_fee" field in this mutation.
func (m *ProductInfoMutation) AddedShippingFee() (r int32, exists bool) {
	v := m.addshipping_fee
	if v == nil {
		return
	}
	return *v, true
}

// ClearShippingFee clears the value of the "shipping_fee" field.
func (m *ProductInfoMutation) ClearShippingFee() {
	m.shipping_fee = nil
	m.addshipping_fee = nil
	m.clearedFields[productinfo.FieldShippingFee] = struct{}{}
}

// ShippingFeeCleared returns if the "shipping_fee" field was cleared in this mutation.
func (m *ProductInfoMutation) ShippingFeeCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldShippingFee]
	return ok
}

// ResetShippingFee resets all changes to the "shipping_fee" field.
func (m *ProductInfoMutation) ResetShippingFee() {
	m.shipping_fee = nil
	m.addshipping_fee = nil
	delete(m.clearedFields, productinfo.FieldShippingFee)
}

// SetPrice sets the "price" field.
func (m *ProductInfoMutation) SetPrice(i int32) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductInfoMutation) Price() (r int32, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *ProductInfoMutation) AddPrice(i int32) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ProductInfoMutation) AddedPrice() (r int32, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *ProductInfoMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[productinfo.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *ProductInfoMutation) PriceCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductInfoMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, productinfo.FieldPrice)
}

// SetIntl sets the "intl" field.
func (m *ProductInfoMutation) SetIntl(b bool) {
	m.intl = &b
}

// Intl returns the value of the "intl" field in the mutation.
func (m *ProductInfoMutation) Intl() (r bool, exists bool) {
	v := m.intl
	if v == nil {
		return
	}
	return *v, true
}

// OldIntl returns the old "intl" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldIntl(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntl: %w", err)
	}
	return oldValue.Intl, nil
}

// ClearIntl clears the value of the "intl" field.
func (m *ProductInfoMutation) ClearIntl() {
	m.intl = nil
	m.clearedFields[productinfo.FieldIntl] = struct{}{}
}

// IntlCleared returns if the "intl" field was cleared in this mutation.
func (m *ProductInfoMutation) IntlCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldIntl]
	return ok
}

// ResetIntl resets all changes to the "intl" field.
func (m *ProductInfoMutation) ResetIntl() {
	m.intl = nil
	delete(m.clearedFields, productinfo.FieldIntl)
}

// SetSearchInfo sets the "search_info" field.
func (m *ProductInfoMutation) SetSearchInfo(s string) {
	m.search_info = &s
}

// SearchInfo returns the value of the "search_info" field in the mutation.
func (m *ProductInfoMutation) SearchInfo() (r string, exists bool) {
	v := m.search_info
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchInfo returns the old "search_info" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldSearchInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchInfo: %w", err)
	}
	return oldValue.SearchInfo, nil
}

// ClearSearchInfo clears the value of the "search_info" field.
func (m *ProductInfoMutation) ClearSearchInfo() {
	m.search_info = nil
	m.clearedFields[productinfo.FieldSearchInfo] = struct{}{}
}

// SearchInfoCleared returns if the "search_info" field was cleared in this mutation.
func (m *ProductInfoMutation) SearchInfoCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldSearchInfo]
	return ok
}

// ResetSearchInfo resets all changes to the "search_info" field.
func (m *ProductInfoMutation) ResetSearchInfo() {
	m.search_info = nil
	delete(m.clearedFields, productinfo.FieldSearchInfo)
}

// SetColor sets the "color" field.
func (m *ProductInfoMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *ProductInfoMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *ProductInfoMutation) ClearColor() {
	m.color = nil
	m.clearedFields[productinfo.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *ProductInfoMutation) ColorCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *ProductInfoMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, productinfo.FieldColor)
}

// SetCategory sets the "category" field.
func (m *ProductInfoMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ProductInfoMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *ProductInfoMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[productinfo.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *ProductInfoMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *ProductInfoMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, productinfo.FieldCategory)
}

// SetCategorySpec sets the "category_spec" field.
func (m *ProductInfoMutation) SetCategorySpec(s string) {
	m.category_spec = &s
}

// CategorySpec returns the value of the "category_spec" field in the mutation.
func (m *ProductInfoMutation) CategorySpec() (r string, exists bool) {
	v := m.category_spec
	if v == nil {
		return
	}
	return *v, true
}

// OldCategorySpec returns the old "category_spec" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldCategorySpec(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategorySpec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategorySpec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategorySpec: %w", err)
	}
	return oldValue.CategorySpec, nil
}

// ClearCategorySpec clears the value of the "category_spec" field.
func (m *ProductInfoMutation) ClearCategorySpec() {
	m.category_spec = nil
	m.clearedFields[productinfo.FieldCategorySpec] = struct{}{}
}

// CategorySpecCleared returns if the "category_spec" field was cleared in this mutation.
func (m *ProductInfoMutation) CategorySpecCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldCategorySpec]
	return ok
}

// ResetCategorySpec resets all changes to the "category_spec" field.
func (m *ProductInfoMutation) ResetCategorySpec() {
	m.category_spec = nil
	delete(m.clearedFields, productinfo.FieldCategorySpec)
}

// SetImgType sets the "img_type" field.
func (m *ProductInfoMutation) SetImgType(s string) {
	m.img_type = &s
}

// ImgType returns the value of the "img_type" field in the mutation.
func (m *ProductInfoMutation) ImgType() (r string, exists bool) {
	v := m.img_type
	if v == nil {
		return
	}
	return *v, true
}

// OldImgType returns the old "img_type" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldImgType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImgType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImgType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImgType: %w", err)
	}
	return oldValue.ImgType, nil
}

// ClearImgType clears the value of the "img_type" field.
func (m *ProductInfoMutation) ClearImgType() {
	m.img_type = nil
	m.clearedFields[productinfo.FieldImgType] = struct{}{}
}

// ImgTypeCleared returns if the "img_type" field was cleared in this mutation.
func (m *ProductInfoMutation) ImgTypeCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldImgType]
	return ok
}

// ResetImgType resets all changes to the "img_type" field.
func (m *ProductInfoMutation) ResetImgType() {
	m.img_type = nil
	delete(m.clearedFields, productinfo.FieldImgType)
}

// SetPriceDescCursor sets the "price_desc_cursor" field.
func (m *ProductInfoMutation) SetPriceDescCursor(s string) {
	m.price_desc_cursor = &s
}

// PriceDescCursor returns the value of the "price_desc_cursor" field in the mutation.
func (m *ProductInfoMutation) PriceDescCursor() (r string, exists bool) {
	v := m.price_desc_cursor
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceDescCursor returns the old "price_desc_cursor" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldPriceDescCursor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceDescCursor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceDescCursor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceDescCursor: %w", err)
	}
	return oldValue.PriceDescCursor, nil
}

// ClearPriceDescCursor clears the value of the "price_desc_cursor" field.
func (m *ProductInfoMutation) ClearPriceDescCursor() {
	m.price_desc_cursor = nil
	m.clearedFields[productinfo.FieldPriceDescCursor] = struct{}{}
}

// PriceDescCursorCleared returns if the "price_desc_cursor" field was cleared in this mutation.
func (m *ProductInfoMutation) PriceDescCursorCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldPriceDescCursor]
	return ok
}

// ResetPriceDescCursor resets all changes to the "price_desc_cursor" field.
func (m *ProductInfoMutation) ResetPriceDescCursor() {
	m.price_desc_cursor = nil
	delete(m.clearedFields, productinfo.FieldPriceDescCursor)
}

// SetPriceAscCursor sets the "price_asc_cursor" field.
func (m *ProductInfoMutation) SetPriceAscCursor(s string) {
	m.price_asc_cursor = &s
}

// PriceAscCursor returns the value of the "price_asc_cursor" field in the mutation.
func (m *ProductInfoMutation) PriceAscCursor() (r string, exists bool) {
	v := m.price_asc_cursor
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceAscCursor returns the old "price_asc_cursor" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldPriceAscCursor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceAscCursor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceAscCursor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceAscCursor: %w", err)
	}
	return oldValue.PriceAscCursor, nil
}

// ClearPriceAscCursor clears the value of the "price_asc_cursor" field.
func (m *ProductInfoMutation) ClearPriceAscCursor() {
	m.price_asc_cursor = nil
	m.clearedFields[productinfo.FieldPriceAscCursor] = struct{}{}
}

// PriceAscCursorCleared returns if the "price_asc_cursor" field was cleared in this mutation.
func (m *ProductInfoMutation) PriceAscCursorCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldPriceAscCursor]
	return ok
}

// ResetPriceAscCursor resets all changes to the "price_asc_cursor" field.
func (m *ProductInfoMutation) ResetPriceAscCursor() {
	m.price_asc_cursor = nil
	delete(m.clearedFields, productinfo.FieldPriceAscCursor)
}

// SetDeploy sets the "deploy" field.
func (m *ProductInfoMutation) SetDeploy(i int32) {
	m.deploy = &i
	m.adddeploy = nil
}

// Deploy returns the value of the "deploy" field in the mutation.
func (m *ProductInfoMutation) Deploy() (r int32, exists bool) {
	v := m.deploy
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploy returns the old "deploy" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldDeploy(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploy: %w", err)
	}
	return oldValue.Deploy, nil
}

// AddDeploy adds i to the "deploy" field.
func (m *ProductInfoMutation) AddDeploy(i int32) {
	if m.adddeploy != nil {
		*m.adddeploy += i
	} else {
		m.adddeploy = &i
	}
}

// AddedDeploy returns the value that was added to the "deploy" field in this mutation.
func (m *ProductInfoMutation) AddedDeploy() (r int32, exists bool) {
	v := m.adddeploy
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeploy clears the value of the "deploy" field.
func (m *ProductInfoMutation) ClearDeploy() {
	m.deploy = nil
	m.adddeploy = nil
	m.clearedFields[productinfo.FieldDeploy] = struct{}{}
}

// DeployCleared returns if the "deploy" field was cleared in this mutation.
func (m *ProductInfoMutation) DeployCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldDeploy]
	return ok
}

// ResetDeploy resets all changes to the "deploy" field.
func (m *ProductInfoMutation) ResetDeploy() {
	m.deploy = nil
	m.adddeploy = nil
	delete(m.clearedFields, productinfo.FieldDeploy)
}

// SetKorProductName sets the "kor_product_name" field.
func (m *ProductInfoMutation) SetKorProductName(s string) {
	m.kor_product_name = &s
}

// KorProductName returns the value of the "kor_product_name" field in the mutation.
func (m *ProductInfoMutation) KorProductName() (r string, exists bool) {
	v := m.kor_product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldKorProductName returns the old "kor_product_name" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldKorProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKorProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKorProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKorProductName: %w", err)
	}
	return oldValue.KorProductName, nil
}

// ClearKorProductName clears the value of the "kor_product_name" field.
func (m *ProductInfoMutation) ClearKorProductName() {
	m.kor_product_name = nil
	m.clearedFields[productinfo.FieldKorProductName] = struct{}{}
}

// KorProductNameCleared returns if the "kor_product_name" field was cleared in this mutation.
func (m *ProductInfoMutation) KorProductNameCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldKorProductName]
	return ok
}

// ResetKorProductName resets all changes to the "kor_product_name" field.
func (m *ProductInfoMutation) ResetKorProductName() {
	m.kor_product_name = nil
	delete(m.clearedFields, productinfo.FieldKorProductName)
}

// SetKorBrand sets the "kor_brand" field.
func (m *ProductInfoMutation) SetKorBrand(s string) {
	m.kor_brand = &s
}

// KorBrand returns the value of the "kor_brand" field in the mutation.
func (m *ProductInfoMutation) KorBrand() (r string, exists bool) {
	v := m.kor_brand
	if v == nil {
		return
	}
	return *v, true
}

// OldKorBrand returns the old "kor_brand" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldKorBrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKorBrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKorBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKorBrand: %w", err)
	}
	return oldValue.KorBrand, nil
}

// ClearKorBrand clears the value of the "kor_brand" field.
func (m *ProductInfoMutation) ClearKorBrand() {
	m.kor_brand = nil
	m.clearedFields[productinfo.FieldKorBrand] = struct{}{}
}

// KorBrandCleared returns if the "kor_brand" field was cleared in this mutation.
func (m *ProductInfoMutation) KorBrandCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldKorBrand]
	return ok
}

// ResetKorBrand resets all changes to the "kor_brand" field.
func (m *ProductInfoMutation) ResetKorBrand() {
	m.kor_brand = nil
	delete(m.clearedFields, productinfo.FieldKorBrand)
}

// AddOrderRowIDs adds the "order_rows" edge to the OrderRow entity by ids.
func (m *ProductInfoMutation) AddOrderRowIDs(ids ...int32) {
	if m.order_rows == nil {
		m.order_rows = make(map[int32]struct{})
	}
	for i := range ids {
		m.order_rows[ids[i]] = struct{}{}
	}
}

// ClearOrderRows clears the "order_rows" edge to the OrderRow entity.
func (m *ProductInfoMutation) ClearOrderRows() {
	m.clearedorder_rows = true
}

// OrderRowsCleared reports if the "order_rows" edge to the OrderRow entity was cleared.
func (m *ProductInfoMutation) OrderRowsCleared() bool {
	return m.clearedorder_rows
}

// RemoveOrderRowIDs removes the "order_rows" edge to the OrderRow entity by IDs.
func (m *ProductInfoMutation) RemoveOrderRowIDs(ids ...int32) {
	if m.removedorder_rows == nil {
		m.removedorder_rows = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.order_rows, ids[i])
		m.removedorder_rows[ids[i]] = struct{}{}
	}
}

// RemovedOrderRows returns the removed IDs of the "order_rows" edge to the OrderRow entity.
func (m *ProductInfoMutation) RemovedOrderRowsIDs() (ids []int32) {
	for id := range m.removedorder_rows {
		ids = append(ids, id)
	}
	return
}

// OrderRowsIDs returns the "order_rows" edge IDs in the mutation.
func (m *ProductInfoMutation) OrderRowsIDs() (ids []int32) {
	for id := range m.order_rows {
		ids = append(ids, id)
	}
	return
}

// ResetOrderRows resets all changes to the "order_rows" edge.
func (m *ProductInfoMutation) ResetOrderRows() {
	m.order_rows = nil
	m.clearedorder_rows = false
	m.removedorder_rows = nil
}

// AddSizeIDs adds the "sizes" edge to the Size entity by ids.
func (m *ProductInfoMutation) AddSizeIDs(ids ...int32) {
	if m.sizes == nil {
		m.sizes = make(map[int32]struct{})
	}
	for i := range ids {
		m.sizes[ids[i]] = struct{}{}
	}
}

// ClearSizes clears the "sizes" edge to the Size entity.
func (m *ProductInfoMutation) ClearSizes() {
	m.clearedsizes = true
}

// SizesCleared reports if the "sizes" edge to the Size entity was cleared.
func (m *ProductInfoMutation) SizesCleared() bool {
	return m.clearedsizes
}

// RemoveSizeIDs removes the "sizes" edge to the Size entity by IDs.
func (m *ProductInfoMutation) RemoveSizeIDs(ids ...int32) {
	if m.removedsizes == nil {
		m.removedsizes = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.sizes, ids[i])
		m.removedsizes[ids[i]] = struct{}{}
	}
}

// RemovedSizes returns the removed IDs of the "sizes" edge to the Size entity.
func (m *ProductInfoMutation) RemovedSizesIDs() (ids []int32) {
	for id := range m.removedsizes {
		ids = append(ids, id)
	}
	return
}

// SizesIDs returns the "sizes" edge IDs in the mutation.
func (m *ProductInfoMutation) SizesIDs() (ids []int32) {
	for id := range m.sizes {
		ids = append(ids, id)
	}
	return
}

// ResetSizes resets all changes to the "sizes" edge.
func (m *ProductInfoMutation) ResetSizes() {
	m.sizes = nil
	m.clearedsizes = false
	m.removedsizes = nil
}

// Where appends a list predicates to the ProductInfoMutation builder.
func (m *ProductInfoMutation) Where(ps ...predicate.ProductInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductInfo).
func (m *ProductInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductInfoMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.brand != nil {
		fields = append(fields, productinfo.FieldBrand)
	}
	if m.product_name != nil {
		fields = append(fields, productinfo.FieldProductName)
	}
	if m.product_id != nil {
		fields = append(fields, productinfo.FieldProductID)
	}
	if m.shipping_fee != nil {
		fields = append(fields, productinfo.FieldShippingFee)
	}
	if m.price != nil {
		fields = append(fields, productinfo.FieldPrice)
	}
	if m.intl != nil {
		fields = append(fields, productinfo.FieldIntl)
	}
	if m.search_info != nil {
		fields = append(fields, productinfo.FieldSearchInfo)
	}
	if m.color != nil {
		fields = append(fields, productinfo.FieldColor)
	}
	if m.category != nil {
		fields = append(fields, productinfo.FieldCategory)
	}
	if m.category_spec != nil {
		fields = append(fields, productinfo.FieldCategorySpec)
	}
	if m.img_type != nil {
		fields = append(fields, productinfo.FieldImgType)
	}
	if m.price_desc_cursor != nil {
		fields = append(fields, productinfo.FieldPriceDescCursor)
	}
	if m.price_asc_cursor != nil {
		fields = append(fields, productinfo.FieldPriceAscCursor)
	}
	if m.deploy != nil {
		fields = append(fields, productinfo.FieldDeploy)
	}
	if m.kor_product_name != nil {
		fields = append(fields, productinfo.FieldKorProductName)
	}
	if m.kor_brand != nil {
		fields = append(fields, productinfo.FieldKorBrand)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productinfo.FieldBrand:
		return m.Brand()
	case productinfo.FieldProductName:
		return m.ProductName()
	case productinfo.FieldProductID:
		return m.ProductID()
	case productinfo.FieldShippingFee:
		return m.ShippingFee()
	case productinfo.FieldPrice:
		return m.Price()
	case productinfo.FieldIntl:
		return m.Intl()
	case productinfo.FieldSearchInfo:
		return m.SearchInfo()
	case productinfo.FieldColor:
		return m.Color()
	case productinfo.FieldCategory:
		return m.Category()
	case productinfo.FieldCategorySpec:
		return m.CategorySpec()
	case productinfo.FieldImgType:
		return m.ImgType()
	case productinfo.FieldPriceDescCursor:
		return m.PriceDescCursor()
	case productinfo.FieldPriceAscCursor:
		return m.PriceAscCursor()
	case productinfo.FieldDeploy:
		return m.Deploy()
	case productinfo.FieldKorProductName:
		return m.KorProductName()
	case productinfo.FieldKorBrand:
		return m.KorBrand()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productinfo.FieldBrand:
		return m.OldBrand(ctx)
	case productinfo.FieldProductName:
		return m.OldProductName(ctx)
	case productinfo.FieldProductID:
		return m.OldProductID(ctx)
	case productinfo.FieldShippingFee:
		return m.OldShippingFee(ctx)
	case productinfo.FieldPrice:
		return m.OldPrice(ctx)
	case productinfo.FieldIntl:
		return m.OldIntl(ctx)
	case productinfo.FieldSearchInfo:
		return m.OldSearchInfo(ctx)
	case productinfo.FieldColor:
		return m.OldColor(ctx)
	case productinfo.FieldCategory:
		return m.OldCategory(ctx)
	case productinfo.FieldCategorySpec:
		return m.OldCategorySpec(ctx)
	case productinfo.FieldImgType:
		return m.OldImgType(ctx)
	case productinfo.FieldPriceDescCursor:
		return m.OldPriceDescCursor(ctx)
	case productinfo.FieldPriceAscCursor:
		return m.OldPriceAscCursor(ctx)
	case productinfo.FieldDeploy:
		return m.OldDeploy(ctx)
	case productinfo.FieldKorProductName:
		return m.OldKorProductName(ctx)
	case productinfo.FieldKorBrand:
		return m.OldKorBrand(ctx)
	}
	return nil, fmt.Errorf("unknown ProductInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productinfo.FieldBrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrand(v)
		return nil
	case productinfo.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case productinfo.FieldProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case productinfo.FieldShippingFee:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingFee(v)
		return nil
	case productinfo.FieldPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case productinfo.FieldIntl:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntl(v)
		return nil
	case productinfo.FieldSearchInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchInfo(v)
		return nil
	case productinfo.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case productinfo.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case productinfo.FieldCategorySpec:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategorySpec(v)
		return nil
	case productinfo.FieldImgType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImgType(v)
		return nil
	case productinfo.FieldPriceDescCursor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceDescCursor(v)
		return nil
	case productinfo.FieldPriceAscCursor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceAscCursor(v)
		return nil
	case productinfo.FieldDeploy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploy(v)
		return nil
	case productinfo.FieldKorProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKorProductName(v)
		return nil
	case productinfo.FieldKorBrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKorBrand(v)
		return nil
	}
	return fmt.Errorf("unknown ProductInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductInfoMutation) AddedFields() []string {
	var fields []string
	if m.addshipping_fee != nil {
		fields = append(fields, productinfo.FieldShippingFee)
	}
	if m.addprice != nil {
		fields = append(fields, productinfo.FieldPrice)
	}
	if m.adddeploy != nil {
		fields = append(fields, productinfo.FieldDeploy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productinfo.FieldShippingFee:
		return m.AddedShippingFee()
	case productinfo.FieldPrice:
		return m.AddedPrice()
	case productinfo.FieldDeploy:
		return m.AddedDeploy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productinfo.FieldShippingFee:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShippingFee(v)
		return nil
	case productinfo.FieldPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case productinfo.FieldDeploy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeploy(v)
		return nil
	}
	return fmt.Errorf("unknown ProductInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productinfo.FieldBrand) {
		fields = append(fields, productinfo.FieldBrand)
	}
	if m.FieldCleared(productinfo.FieldProductName) {
		fields = append(fields, productinfo.FieldProductName)
	}
	if m.FieldCleared(productinfo.FieldProductID) {
		fields = append(fields, productinfo.FieldProductID)
	}
	if m.FieldCleared(productinfo.FieldShippingFee) {
		fields = append(fields, productinfo.FieldShippingFee)
	}
	if m.FieldCleared(productinfo.FieldPrice) {
		fields = append(fields, productinfo.FieldPrice)
	}
	if m.FieldCleared(productinfo.FieldIntl) {
		fields = append(fields, productinfo.FieldIntl)
	}
	if m.FieldCleared(productinfo.FieldSearchInfo) {
		fields = append(fields, productinfo.FieldSearchInfo)
	}
	if m.FieldCleared(productinfo.FieldColor) {
		fields = append(fields, productinfo.FieldColor)
	}
	if m.FieldCleared(productinfo.FieldCategory) {
		fields = append(fields, productinfo.FieldCategory)
	}
	if m.FieldCleared(productinfo.FieldCategorySpec) {
		fields = append(fields, productinfo.FieldCategorySpec)
	}
	if m.FieldCleared(productinfo.FieldImgType) {
		fields = append(fields, productinfo.FieldImgType)
	}
	if m.FieldCleared(productinfo.FieldPriceDescCursor) {
		fields = append(fields, productinfo.FieldPriceDescCursor)
	}
	if m.FieldCleared(productinfo.FieldPriceAscCursor) {
		fields = append(fields, productinfo.FieldPriceAscCursor)
	}
	if m.FieldCleared(productinfo.FieldDeploy) {
		fields = append(fields, productinfo.FieldDeploy)
	}
	if m.FieldCleared(productinfo.FieldKorProductName) {
		fields = append(fields, productinfo.FieldKorProductName)
	}
	if m.FieldCleared(productinfo.FieldKorBrand) {
		fields = append(fields, productinfo.FieldKorBrand)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductInfoMutation) ClearField(name string) error {
	switch name {
	case productinfo.FieldBrand:
		m.ClearBrand()
		return nil
	case productinfo.FieldProductName:
		m.ClearProductName()
		return nil
	case productinfo.FieldProductID:
		m.ClearProductID()
		return nil
	case productinfo.FieldShippingFee:
		m.ClearShippingFee()
		return nil
	case productinfo.FieldPrice:
		m.ClearPrice()
		return nil
	case productinfo.FieldIntl:
		m.ClearIntl()
		return nil
	case productinfo.FieldSearchInfo:
		m.ClearSearchInfo()
		return nil
	case productinfo.FieldColor:
		m.ClearColor()
		return nil
	case productinfo.FieldCategory:
		m.ClearCategory()
		return nil
	case productinfo.FieldCategorySpec:
		m.ClearCategorySpec()
		return nil
	case productinfo.FieldImgType:
		m.ClearImgType()
		return nil
	case productinfo.FieldPriceDescCursor:
		m.ClearPriceDescCursor()
		return nil
	case productinfo.FieldPriceAscCursor:
		m.ClearPriceAscCursor()
		return nil
	case productinfo.FieldDeploy:
		m.ClearDeploy()
		return nil
	case productinfo.FieldKorProductName:
		m.ClearKorProductName()
		return nil
	case productinfo.FieldKorBrand:
		m.ClearKorBrand()
		return nil
	}
	return fmt.Errorf("unknown ProductInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductInfoMutation) ResetField(name string) error {
	switch name {
	case productinfo.FieldBrand:
		m.ResetBrand()
		return nil
	case productinfo.FieldProductName:
		m.ResetProductName()
		return nil
	case productinfo.FieldProductID:
		m.ResetProductID()
		return nil
	case productinfo.FieldShippingFee:
		m.ResetShippingFee()
		return nil
	case productinfo.FieldPrice:
		m.ResetPrice()
		return nil
	case productinfo.FieldIntl:
		m.ResetIntl()
		return nil
	case productinfo.FieldSearchInfo:
		m.ResetSearchInfo()
		return nil
	case productinfo.FieldColor:
		m.ResetColor()
		return nil
	case productinfo.FieldCategory:
		m.ResetCategory()
		return nil
	case productinfo.FieldCategorySpec:
		m.ResetCategorySpec()
		return nil
	case productinfo.FieldImgType:
		m.ResetImgType()
		return nil
	case productinfo.FieldPriceDescCursor:
		m.ResetPriceDescCursor()
		return nil
	case productinfo.FieldPriceAscCursor:
		m.ResetPriceAscCursor()
		return nil
	case productinfo.FieldDeploy:
		m.ResetDeploy()
		return nil
	case productinfo.FieldKorProductName:
		m.ResetKorProductName()
		return nil
	case productinfo.FieldKorBrand:
		m.ResetKorBrand()
		return nil
	}
	return fmt.Errorf("unknown ProductInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.order_rows != nil {
		edges = append(edges, productinfo.EdgeOrderRows)
	}
	if m.sizes != nil {
		edges = append(edges, productinfo.EdgeSizes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productinfo.EdgeOrderRows:
		ids := make([]ent.Value, 0, len(m.order_rows))
		for id := range m.order_rows {
			ids = append(ids, id)
		}
		return ids
	case productinfo.EdgeSizes:
		ids := make([]ent.Value, 0, len(m.sizes))
		for id := range m.sizes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedorder_rows != nil {
		edges = append(edges, productinfo.EdgeOrderRows)
	}
	if m.removedsizes != nil {
		edges = append(edges, productinfo.EdgeSizes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productinfo.EdgeOrderRows:
		ids := make([]ent.Value, 0, len(m.removedorder_rows))
		for id := range m.removedorder_rows {
			ids = append(ids, id)
		}
		return ids
	case productinfo.EdgeSizes:
		ids := make([]ent.Value, 0, len(m.removedsizes))
		for id := range m.removedsizes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorder_rows {
		edges = append(edges, productinfo.EdgeOrderRows)
	}
	if m.clearedsizes {
		edges = append(edges, productinfo.EdgeSizes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case productinfo.EdgeOrderRows:
		return m.clearedorder_rows
	case productinfo.EdgeSizes:
		return m.clearedsizes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductInfoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductInfoMutation) ResetEdge(name string) error {
	switch name {
	case productinfo.EdgeOrderRows:
		m.ResetOrderRows()
		return nil
	case productinfo.EdgeSizes:
		m.ResetSizes()
		return nil
	}
	return fmt.Errorf("unknown ProductInfo edge %s", name)
}

// SizeMutation represents an operation that mutates the Size nodes in the graph.
type SizeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int32
	size                *string
	available           *bool
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	product_info        *int32
	clearedproduct_info bool
	done                bool
	oldValue            func(context.Context) (*Size, error)
	predicates          []predicate.Size
}

var _ ent.Mutation = (*SizeMutation)(nil)

// sizeOption allows management of the mutation configuration using functional options.
type sizeOption func(*SizeMutation)

// newSizeMutation creates new mutation for the Size entity.
func newSizeMutation(c config, op Op, opts ...sizeOption) *SizeMutation {
	m := &SizeMutation{
		config:        c,
		op:            op,
		typ:           TypeSize,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSizeID sets the ID field of the mutation.
func withSizeID(id int32) sizeOption {
	return func(m *SizeMutation) {
		var (
			err   error
			once  sync.Once
			value *Size
		)
		m.oldValue = func(ctx context.Context) (*Size, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Size.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSize sets the old Size of the mutation.
func withSize(node *Size) sizeOption {
	return func(m *SizeMutation) {
		m.oldValue = func(context.Context) (*Size, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SizeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SizeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Size entities.
func (m *SizeMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SizeMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SizeMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Size.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSku sets the "sku" field.
func (m *SizeMutation) SetSku(i int32) {
	m.product_info = &i
}

// Sku returns the value of the "sku" field in the mutation.
func (m *SizeMutation) Sku() (r int32, exists bool) {
	v := m.product_info
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the Size entity.
// If the Size object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SizeMutation) OldSku(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ClearSku clears the value of the "sku" field.
func (m *SizeMutation) ClearSku() {
	m.product_info = nil
	m.clearedFields[size.FieldSku] = struct{}{}
}

// SkuCleared returns if the "sku" field was cleared in this mutation.
func (m *SizeMutation) SkuCleared() bool {
	_, ok := m.clearedFields[size.FieldSku]
	return ok
}

// ResetSku resets all changes to the "sku" field.
func (m *SizeMutation) ResetSku() {
	m.product_info = nil
	delete(m.clearedFields, size.FieldSku)
}

// SetSize sets the "size" field.
func (m *SizeMutation) SetSize(s string) {
	m.size = &s
}

// Size returns the value of the "size" field in the mutation.
func (m *SizeMutation) Size() (r string, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Size entity.
// If the Size object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SizeMutation) OldSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// ResetSize resets all changes to the "size" field.
func (m *SizeMutation) ResetSize() {
	m.size = nil
}

// SetAvailable sets the "available" field.
func (m *SizeMutation) SetAvailable(b bool) {
	m.available = &b
}

// Available returns the value of the "available" field in the mutation.
func (m *SizeMutation) Available() (r bool, exists bool) {
	v := m.available
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailable returns the old "available" field's value of the Size entity.
// If the Size object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SizeMutation) OldAvailable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailable: %w", err)
	}
	return oldValue.Available, nil
}

// ResetAvailable resets all changes to the "available" field.
func (m *SizeMutation) ResetAvailable() {
	m.available = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SizeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SizeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Size entity.
// If the Size object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SizeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SizeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProductInfoID sets the "product_info" edge to the ProductInfo entity by id.
func (m *SizeMutation) SetProductInfoID(id int32) {
	m.product_info = &id
}

// ClearProductInfo clears the "product_info" edge to the ProductInfo entity.
func (m *SizeMutation) ClearProductInfo() {
	m.clearedproduct_info = true
	m.clearedFields[size.FieldSku] = struct{}{}
}

// ProductInfoCleared reports if the "product_info" edge to the ProductInfo entity was cleared.
func (m *SizeMutation) ProductInfoCleared() bool {
	return m.SkuCleared() || m.clearedproduct_info
}

// ProductInfoID returns the "product_info" edge ID in the mutation.
func (m *SizeMutation) ProductInfoID() (id int32, exists bool) {
	if m.product_info != nil {
		return *m.product_info, true
	}
	return
}

// ProductInfoIDs returns the "product_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductInfoID instead. It exists only for internal usage by the builders.
func (m *SizeMutation) ProductInfoIDs() (ids []int32) {
	if id := m.product_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductInfo resets all changes to the "product_info" edge.
func (m *SizeMutation) ResetProductInfo() {
	m.product_info = nil
	m.clearedproduct_info = false
}

// Where appends a list predicates to the SizeMutation builder.
func (m *SizeMutation) Where(ps ...predicate.Size) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SizeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SizeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Size, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SizeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SizeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Size).
func (m *SizeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SizeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.product_info != nil {
		fields = append(fields, size.FieldSku)
	}
	if m.size != nil {
		fields = append(fields, size.FieldSize)
	}
	if m.available != nil {
		fields = append(fields, size.FieldAvailable)
	}
	if m.updated_at != nil {
		fields = append(fields, size.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SizeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case size.FieldSku:
		return m.Sku()
	case size.FieldSize:
		return m.Size()
	case size.FieldAvailable:
		return m.Available()
	case size.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SizeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case size.FieldSku:
		return m.OldSku(ctx)
	case size.FieldSize:
		return m.OldSize(ctx)
	case size.FieldAvailable:
		return m.OldAvailable(ctx)
	case size.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Size field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SizeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case size.FieldSku:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case size.FieldSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case size.FieldAvailable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailable(v)
		return nil
	case size.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Size field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SizeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SizeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SizeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Size numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SizeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(size.FieldSku) {
		fields = append(fields, size.FieldSku)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SizeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SizeMutation) ClearField(name string) error {
	switch name {
	case size.FieldSku:
		m.ClearSku()
		return nil
	}
	return fmt.Errorf("unknown Size nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SizeMutation) ResetField(name string) error {
	switch name {
	case size.FieldSku:
		m.ResetSku()
		return nil
	case size.FieldSize:
		m.ResetSize()
		return nil
	case size.FieldAvailable:
		m.ResetAvailable()
		return nil
	case size.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Size field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SizeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.product_info != nil {
		edges = append(edges, size.EdgeProductInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SizeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case size.EdgeProductInfo:
		if id := m.product_info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SizeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SizeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SizeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproduct_info {
		edges = append(edges, size.EdgeProductInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SizeMutation) EdgeCleared(name string) bool {
	switch name {
	case size.EdgeProductInfo:
		return m.clearedproduct_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SizeMutation) ClearEdge(name string) error {
	switch name {
	case size.EdgeProductInfo:
		m.ClearProductInfo()
		return nil
	}
	return fmt.Errorf("unknown Size unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SizeMutation) ResetEdge(name string) error {
	switch name {
	case size.EdgeProductInfo:
		m.ResetProductInfo()
		return nil
	}
	return fmt.Errorf("unknown Size edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	email                  *string
	password               *string
	kr_name                *string
	register_at            *time.Time
	last_login             *time.Time
	sign_up_type           *string
	clearedFields          map[string]struct{}
	order_histories        map[string]struct{}
	removedorder_histories map[string]struct{}
	clearedorder_histories bool
	user_address           map[string]struct{}
	removeduser_address    map[string]struct{}
	cleareduser_address    bool
	done                   bool
	oldValue               func(context.Context) (*User, error)
	predicates             []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[user.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, user.FieldPassword)
}

// SetKrName sets the "kr_name" field.
func (m *UserMutation) SetKrName(s string) {
	m.kr_name = &s
}

// KrName returns the value of the "kr_name" field in the mutation.
func (m *UserMutation) KrName() (r string, exists bool) {
	v := m.kr_name
	if v == nil {
		return
	}
	return *v, true
}

// OldKrName returns the old "kr_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldKrName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKrName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKrName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKrName: %w", err)
	}
	return oldValue.KrName, nil
}

// ResetKrName resets all changes to the "kr_name" field.
func (m *UserMutation) ResetKrName() {
	m.kr_name = nil
}

// SetRegisterAt sets the "register_at" field.
func (m *UserMutation) SetRegisterAt(t time.Time) {
	m.register_at = &t
}

// RegisterAt returns the value of the "register_at" field in the mutation.
func (m *UserMutation) RegisterAt() (r time.Time, exists bool) {
	v := m.register_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisterAt returns the old "register_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRegisterAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegisterAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegisterAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisterAt: %w", err)
	}
	return oldValue.RegisterAt, nil
}

// ResetRegisterAt resets all changes to the "register_at" field.
func (m *UserMutation) ResetRegisterAt() {
	m.register_at = nil
}

// SetLastLogin sets the "last_login" field.
func (m *UserMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *UserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLogin(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *UserMutation) ResetLastLogin() {
	m.last_login = nil
}

// SetSignUpType sets the "sign_up_type" field.
func (m *UserMutation) SetSignUpType(s string) {
	m.sign_up_type = &s
}

// SignUpType returns the value of the "sign_up_type" field in the mutation.
func (m *UserMutation) SignUpType() (r string, exists bool) {
	v := m.sign_up_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSignUpType returns the old "sign_up_type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSignUpType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignUpType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignUpType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignUpType: %w", err)
	}
	return oldValue.SignUpType, nil
}

// ResetSignUpType resets all changes to the "sign_up_type" field.
func (m *UserMutation) ResetSignUpType() {
	m.sign_up_type = nil
}

// AddOrderHistoryIDs adds the "order_histories" edge to the OrderHistory entity by ids.
func (m *UserMutation) AddOrderHistoryIDs(ids ...string) {
	if m.order_histories == nil {
		m.order_histories = make(map[string]struct{})
	}
	for i := range ids {
		m.order_histories[ids[i]] = struct{}{}
	}
}

// ClearOrderHistories clears the "order_histories" edge to the OrderHistory entity.
func (m *UserMutation) ClearOrderHistories() {
	m.clearedorder_histories = true
}

// OrderHistoriesCleared reports if the "order_histories" edge to the OrderHistory entity was cleared.
func (m *UserMutation) OrderHistoriesCleared() bool {
	return m.clearedorder_histories
}

// RemoveOrderHistoryIDs removes the "order_histories" edge to the OrderHistory entity by IDs.
func (m *UserMutation) RemoveOrderHistoryIDs(ids ...string) {
	if m.removedorder_histories == nil {
		m.removedorder_histories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.order_histories, ids[i])
		m.removedorder_histories[ids[i]] = struct{}{}
	}
}

// RemovedOrderHistories returns the removed IDs of the "order_histories" edge to the OrderHistory entity.
func (m *UserMutation) RemovedOrderHistoriesIDs() (ids []string) {
	for id := range m.removedorder_histories {
		ids = append(ids, id)
	}
	return
}

// OrderHistoriesIDs returns the "order_histories" edge IDs in the mutation.
func (m *UserMutation) OrderHistoriesIDs() (ids []string) {
	for id := range m.order_histories {
		ids = append(ids, id)
	}
	return
}

// ResetOrderHistories resets all changes to the "order_histories" edge.
func (m *UserMutation) ResetOrderHistories() {
	m.order_histories = nil
	m.clearedorder_histories = false
	m.removedorder_histories = nil
}

// AddUserAddresIDs adds the "user_address" edge to the UserAddress entity by ids.
func (m *UserMutation) AddUserAddresIDs(ids ...string) {
	if m.user_address == nil {
		m.user_address = make(map[string]struct{})
	}
	for i := range ids {
		m.user_address[ids[i]] = struct{}{}
	}
}

// ClearUserAddress clears the "user_address" edge to the UserAddress entity.
func (m *UserMutation) ClearUserAddress() {
	m.cleareduser_address = true
}

// UserAddressCleared reports if the "user_address" edge to the UserAddress entity was cleared.
func (m *UserMutation) UserAddressCleared() bool {
	return m.cleareduser_address
}

// RemoveUserAddresIDs removes the "user_address" edge to the UserAddress entity by IDs.
func (m *UserMutation) RemoveUserAddresIDs(ids ...string) {
	if m.removeduser_address == nil {
		m.removeduser_address = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user_address, ids[i])
		m.removeduser_address[ids[i]] = struct{}{}
	}
}

// RemovedUserAddress returns the removed IDs of the "user_address" edge to the UserAddress entity.
func (m *UserMutation) RemovedUserAddressIDs() (ids []string) {
	for id := range m.removeduser_address {
		ids = append(ids, id)
	}
	return
}

// UserAddressIDs returns the "user_address" edge IDs in the mutation.
func (m *UserMutation) UserAddressIDs() (ids []string) {
	for id := range m.user_address {
		ids = append(ids, id)
	}
	return
}

// ResetUserAddress resets all changes to the "user_address" edge.
func (m *UserMutation) ResetUserAddress() {
	m.user_address = nil
	m.cleareduser_address = false
	m.removeduser_address = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.kr_name != nil {
		fields = append(fields, user.FieldKrName)
	}
	if m.register_at != nil {
		fields = append(fields, user.FieldRegisterAt)
	}
	if m.last_login != nil {
		fields = append(fields, user.FieldLastLogin)
	}
	if m.sign_up_type != nil {
		fields = append(fields, user.FieldSignUpType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldKrName:
		return m.KrName()
	case user.FieldRegisterAt:
		return m.RegisterAt()
	case user.FieldLastLogin:
		return m.LastLogin()
	case user.FieldSignUpType:
		return m.SignUpType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldKrName:
		return m.OldKrName(ctx)
	case user.FieldRegisterAt:
		return m.OldRegisterAt(ctx)
	case user.FieldLastLogin:
		return m.OldLastLogin(ctx)
	case user.FieldSignUpType:
		return m.OldSignUpType(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldKrName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKrName(v)
		return nil
	case user.FieldRegisterAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisterAt(v)
		return nil
	case user.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	case user.FieldSignUpType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignUpType(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldPassword) {
		fields = append(fields, user.FieldPassword)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldPassword:
		m.ClearPassword()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldKrName:
		m.ResetKrName()
		return nil
	case user.FieldRegisterAt:
		m.ResetRegisterAt()
		return nil
	case user.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	case user.FieldSignUpType:
		m.ResetSignUpType()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.order_histories != nil {
		edges = append(edges, user.EdgeOrderHistories)
	}
	if m.user_address != nil {
		edges = append(edges, user.EdgeUserAddress)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOrderHistories:
		ids := make([]ent.Value, 0, len(m.order_histories))
		for id := range m.order_histories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserAddress:
		ids := make([]ent.Value, 0, len(m.user_address))
		for id := range m.user_address {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedorder_histories != nil {
		edges = append(edges, user.EdgeOrderHistories)
	}
	if m.removeduser_address != nil {
		edges = append(edges, user.EdgeUserAddress)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOrderHistories:
		ids := make([]ent.Value, 0, len(m.removedorder_histories))
		for id := range m.removedorder_histories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserAddress:
		ids := make([]ent.Value, 0, len(m.removeduser_address))
		for id := range m.removeduser_address {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorder_histories {
		edges = append(edges, user.EdgeOrderHistories)
	}
	if m.cleareduser_address {
		edges = append(edges, user.EdgeUserAddress)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeOrderHistories:
		return m.clearedorder_histories
	case user.EdgeUserAddress:
		return m.cleareduser_address
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeOrderHistories:
		m.ResetOrderHistories()
		return nil
	case user.EdgeUserAddress:
		m.ResetUserAddress()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserAddressMutation represents an operation that mutates the UserAddress nodes in the graph.
type UserAddressMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	kr_name                *string
	en_name                *string
	custom_id              *string
	phone                  *string
	kr_address             *string
	kr_address_detail      *string
	en_address             *string
	en_address_detail      *string
	permanent              *bool
	clearedFields          map[string]struct{}
	order_histories        map[string]struct{}
	removedorder_histories map[string]struct{}
	clearedorder_histories bool
	user                   *string
	cleareduser            bool
	done                   bool
	oldValue               func(context.Context) (*UserAddress, error)
	predicates             []predicate.UserAddress
}

var _ ent.Mutation = (*UserAddressMutation)(nil)

// useraddressOption allows management of the mutation configuration using functional options.
type useraddressOption func(*UserAddressMutation)

// newUserAddressMutation creates new mutation for the UserAddress entity.
func newUserAddressMutation(c config, op Op, opts ...useraddressOption) *UserAddressMutation {
	m := &UserAddressMutation{
		config:        c,
		op:            op,
		typ:           TypeUserAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserAddressID sets the ID field of the mutation.
func withUserAddressID(id string) useraddressOption {
	return func(m *UserAddressMutation) {
		var (
			err   error
			once  sync.Once
			value *UserAddress
		)
		m.oldValue = func(ctx context.Context) (*UserAddress, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserAddress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserAddress sets the old UserAddress of the mutation.
func withUserAddress(node *UserAddress) useraddressOption {
	return func(m *UserAddressMutation) {
		m.oldValue = func(context.Context) (*UserAddress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserAddress entities.
func (m *UserAddressMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserAddressMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserAddressMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserAddress.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserAddressMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserAddressMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserAddress entity.
// If the UserAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAddressMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserAddressMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[useraddress.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserAddressMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[useraddress.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserAddressMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, useraddress.FieldUserID)
}

// SetKrName sets the "kr_name" field.
func (m *UserAddressMutation) SetKrName(s string) {
	m.kr_name = &s
}

// KrName returns the value of the "kr_name" field in the mutation.
func (m *UserAddressMutation) KrName() (r string, exists bool) {
	v := m.kr_name
	if v == nil {
		return
	}
	return *v, true
}

// OldKrName returns the old "kr_name" field's value of the UserAddress entity.
// If the UserAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAddressMutation) OldKrName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKrName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKrName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKrName: %w", err)
	}
	return oldValue.KrName, nil
}

// ResetKrName resets all changes to the "kr_name" field.
func (m *UserAddressMutation) ResetKrName() {
	m.kr_name = nil
}

// SetEnName sets the "en_name" field.
func (m *UserAddressMutation) SetEnName(s string) {
	m.en_name = &s
}

// EnName returns the value of the "en_name" field in the mutation.
func (m *UserAddressMutation) EnName() (r string, exists bool) {
	v := m.en_name
	if v == nil {
		return
	}
	return *v, true
}

// OldEnName returns the old "en_name" field's value of the UserAddress entity.
// If the UserAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAddressMutation) OldEnName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnName: %w", err)
	}
	return oldValue.EnName, nil
}

// ResetEnName resets all changes to the "en_name" field.
func (m *UserAddressMutation) ResetEnName() {
	m.en_name = nil
}

// SetCustomID sets the "custom_id" field.
func (m *UserAddressMutation) SetCustomID(s string) {
	m.custom_id = &s
}

// CustomID returns the value of the "custom_id" field in the mutation.
func (m *UserAddressMutation) CustomID() (r string, exists bool) {
	v := m.custom_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomID returns the old "custom_id" field's value of the UserAddress entity.
// If the UserAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAddressMutation) OldCustomID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomID: %w", err)
	}
	return oldValue.CustomID, nil
}

// ResetCustomID resets all changes to the "custom_id" field.
func (m *UserAddressMutation) ResetCustomID() {
	m.custom_id = nil
}

// SetPhone sets the "phone" field.
func (m *UserAddressMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserAddressMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the UserAddress entity.
// If the UserAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAddressMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserAddressMutation) ResetPhone() {
	m.phone = nil
}

// SetKrAddress sets the "kr_address" field.
func (m *UserAddressMutation) SetKrAddress(s string) {
	m.kr_address = &s
}

// KrAddress returns the value of the "kr_address" field in the mutation.
func (m *UserAddressMutation) KrAddress() (r string, exists bool) {
	v := m.kr_address
	if v == nil {
		return
	}
	return *v, true
}

// OldKrAddress returns the old "kr_address" field's value of the UserAddress entity.
// If the UserAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAddressMutation) OldKrAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKrAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKrAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKrAddress: %w", err)
	}
	return oldValue.KrAddress, nil
}

// ResetKrAddress resets all changes to the "kr_address" field.
func (m *UserAddressMutation) ResetKrAddress() {
	m.kr_address = nil
}

// SetKrAddressDetail sets the "kr_address_detail" field.
func (m *UserAddressMutation) SetKrAddressDetail(s string) {
	m.kr_address_detail = &s
}

// KrAddressDetail returns the value of the "kr_address_detail" field in the mutation.
func (m *UserAddressMutation) KrAddressDetail() (r string, exists bool) {
	v := m.kr_address_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldKrAddressDetail returns the old "kr_address_detail" field's value of the UserAddress entity.
// If the UserAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAddressMutation) OldKrAddressDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKrAddressDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKrAddressDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKrAddressDetail: %w", err)
	}
	return oldValue.KrAddressDetail, nil
}

// ResetKrAddressDetail resets all changes to the "kr_address_detail" field.
func (m *UserAddressMutation) ResetKrAddressDetail() {
	m.kr_address_detail = nil
}

// SetEnAddress sets the "en_address" field.
func (m *UserAddressMutation) SetEnAddress(s string) {
	m.en_address = &s
}

// EnAddress returns the value of the "en_address" field in the mutation.
func (m *UserAddressMutation) EnAddress() (r string, exists bool) {
	v := m.en_address
	if v == nil {
		return
	}
	return *v, true
}

// OldEnAddress returns the old "en_address" field's value of the UserAddress entity.
// If the UserAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAddressMutation) OldEnAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnAddress: %w", err)
	}
	return oldValue.EnAddress, nil
}

// ResetEnAddress resets all changes to the "en_address" field.
func (m *UserAddressMutation) ResetEnAddress() {
	m.en_address = nil
}

// SetEnAddressDetail sets the "en_address_detail" field.
func (m *UserAddressMutation) SetEnAddressDetail(s string) {
	m.en_address_detail = &s
}

// EnAddressDetail returns the value of the "en_address_detail" field in the mutation.
func (m *UserAddressMutation) EnAddressDetail() (r string, exists bool) {
	v := m.en_address_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldEnAddressDetail returns the old "en_address_detail" field's value of the UserAddress entity.
// If the UserAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAddressMutation) OldEnAddressDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnAddressDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnAddressDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnAddressDetail: %w", err)
	}
	return oldValue.EnAddressDetail, nil
}

// ResetEnAddressDetail resets all changes to the "en_address_detail" field.
func (m *UserAddressMutation) ResetEnAddressDetail() {
	m.en_address_detail = nil
}

// SetPermanent sets the "permanent" field.
func (m *UserAddressMutation) SetPermanent(b bool) {
	m.permanent = &b
}

// Permanent returns the value of the "permanent" field in the mutation.
func (m *UserAddressMutation) Permanent() (r bool, exists bool) {
	v := m.permanent
	if v == nil {
		return
	}
	return *v, true
}

// OldPermanent returns the old "permanent" field's value of the UserAddress entity.
// If the UserAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAddressMutation) OldPermanent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermanent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermanent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermanent: %w", err)
	}
	return oldValue.Permanent, nil
}

// ResetPermanent resets all changes to the "permanent" field.
func (m *UserAddressMutation) ResetPermanent() {
	m.permanent = nil
}

// AddOrderHistoryIDs adds the "order_histories" edge to the OrderHistory entity by ids.
func (m *UserAddressMutation) AddOrderHistoryIDs(ids ...string) {
	if m.order_histories == nil {
		m.order_histories = make(map[string]struct{})
	}
	for i := range ids {
		m.order_histories[ids[i]] = struct{}{}
	}
}

// ClearOrderHistories clears the "order_histories" edge to the OrderHistory entity.
func (m *UserAddressMutation) ClearOrderHistories() {
	m.clearedorder_histories = true
}

// OrderHistoriesCleared reports if the "order_histories" edge to the OrderHistory entity was cleared.
func (m *UserAddressMutation) OrderHistoriesCleared() bool {
	return m.clearedorder_histories
}

// RemoveOrderHistoryIDs removes the "order_histories" edge to the OrderHistory entity by IDs.
func (m *UserAddressMutation) RemoveOrderHistoryIDs(ids ...string) {
	if m.removedorder_histories == nil {
		m.removedorder_histories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.order_histories, ids[i])
		m.removedorder_histories[ids[i]] = struct{}{}
	}
}

// RemovedOrderHistories returns the removed IDs of the "order_histories" edge to the OrderHistory entity.
func (m *UserAddressMutation) RemovedOrderHistoriesIDs() (ids []string) {
	for id := range m.removedorder_histories {
		ids = append(ids, id)
	}
	return
}

// OrderHistoriesIDs returns the "order_histories" edge IDs in the mutation.
func (m *UserAddressMutation) OrderHistoriesIDs() (ids []string) {
	for id := range m.order_histories {
		ids = append(ids, id)
	}
	return
}

// ResetOrderHistories resets all changes to the "order_histories" edge.
func (m *UserAddressMutation) ResetOrderHistories() {
	m.order_histories = nil
	m.clearedorder_histories = false
	m.removedorder_histories = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserAddressMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[useraddress.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserAddressMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserAddressMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserAddressMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserAddressMutation builder.
func (m *UserAddressMutation) Where(ps ...predicate.UserAddress) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserAddressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserAddressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserAddress, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserAddressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserAddressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserAddress).
func (m *UserAddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAddressMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.user != nil {
		fields = append(fields, useraddress.FieldUserID)
	}
	if m.kr_name != nil {
		fields = append(fields, useraddress.FieldKrName)
	}
	if m.en_name != nil {
		fields = append(fields, useraddress.FieldEnName)
	}
	if m.custom_id != nil {
		fields = append(fields, useraddress.FieldCustomID)
	}
	if m.phone != nil {
		fields = append(fields, useraddress.FieldPhone)
	}
	if m.kr_address != nil {
		fields = append(fields, useraddress.FieldKrAddress)
	}
	if m.kr_address_detail != nil {
		fields = append(fields, useraddress.FieldKrAddressDetail)
	}
	if m.en_address != nil {
		fields = append(fields, useraddress.FieldEnAddress)
	}
	if m.en_address_detail != nil {
		fields = append(fields, useraddress.FieldEnAddressDetail)
	}
	if m.permanent != nil {
		fields = append(fields, useraddress.FieldPermanent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useraddress.FieldUserID:
		return m.UserID()
	case useraddress.FieldKrName:
		return m.KrName()
	case useraddress.FieldEnName:
		return m.EnName()
	case useraddress.FieldCustomID:
		return m.CustomID()
	case useraddress.FieldPhone:
		return m.Phone()
	case useraddress.FieldKrAddress:
		return m.KrAddress()
	case useraddress.FieldKrAddressDetail:
		return m.KrAddressDetail()
	case useraddress.FieldEnAddress:
		return m.EnAddress()
	case useraddress.FieldEnAddressDetail:
		return m.EnAddressDetail()
	case useraddress.FieldPermanent:
		return m.Permanent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useraddress.FieldUserID:
		return m.OldUserID(ctx)
	case useraddress.FieldKrName:
		return m.OldKrName(ctx)
	case useraddress.FieldEnName:
		return m.OldEnName(ctx)
	case useraddress.FieldCustomID:
		return m.OldCustomID(ctx)
	case useraddress.FieldPhone:
		return m.OldPhone(ctx)
	case useraddress.FieldKrAddress:
		return m.OldKrAddress(ctx)
	case useraddress.FieldKrAddressDetail:
		return m.OldKrAddressDetail(ctx)
	case useraddress.FieldEnAddress:
		return m.OldEnAddress(ctx)
	case useraddress.FieldEnAddressDetail:
		return m.OldEnAddressDetail(ctx)
	case useraddress.FieldPermanent:
		return m.OldPermanent(ctx)
	}
	return nil, fmt.Errorf("unknown UserAddress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useraddress.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case useraddress.FieldKrName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKrName(v)
		return nil
	case useraddress.FieldEnName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnName(v)
		return nil
	case useraddress.FieldCustomID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomID(v)
		return nil
	case useraddress.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case useraddress.FieldKrAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKrAddress(v)
		return nil
	case useraddress.FieldKrAddressDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKrAddressDetail(v)
		return nil
	case useraddress.FieldEnAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnAddress(v)
		return nil
	case useraddress.FieldEnAddressDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnAddressDetail(v)
		return nil
	case useraddress.FieldPermanent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermanent(v)
		return nil
	}
	return fmt.Errorf("unknown UserAddress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserAddress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAddressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(useraddress.FieldUserID) {
		fields = append(fields, useraddress.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAddressMutation) ClearField(name string) error {
	switch name {
	case useraddress.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown UserAddress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAddressMutation) ResetField(name string) error {
	switch name {
	case useraddress.FieldUserID:
		m.ResetUserID()
		return nil
	case useraddress.FieldKrName:
		m.ResetKrName()
		return nil
	case useraddress.FieldEnName:
		m.ResetEnName()
		return nil
	case useraddress.FieldCustomID:
		m.ResetCustomID()
		return nil
	case useraddress.FieldPhone:
		m.ResetPhone()
		return nil
	case useraddress.FieldKrAddress:
		m.ResetKrAddress()
		return nil
	case useraddress.FieldKrAddressDetail:
		m.ResetKrAddressDetail()
		return nil
	case useraddress.FieldEnAddress:
		m.ResetEnAddress()
		return nil
	case useraddress.FieldEnAddressDetail:
		m.ResetEnAddressDetail()
		return nil
	case useraddress.FieldPermanent:
		m.ResetPermanent()
		return nil
	}
	return fmt.Errorf("unknown UserAddress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.order_histories != nil {
		edges = append(edges, useraddress.EdgeOrderHistories)
	}
	if m.user != nil {
		edges = append(edges, useraddress.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case useraddress.EdgeOrderHistories:
		ids := make([]ent.Value, 0, len(m.order_histories))
		for id := range m.order_histories {
			ids = append(ids, id)
		}
		return ids
	case useraddress.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedorder_histories != nil {
		edges = append(edges, useraddress.EdgeOrderHistories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAddressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case useraddress.EdgeOrderHistories:
		ids := make([]ent.Value, 0, len(m.removedorder_histories))
		for id := range m.removedorder_histories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorder_histories {
		edges = append(edges, useraddress.EdgeOrderHistories)
	}
	if m.cleareduser {
		edges = append(edges, useraddress.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAddressMutation) EdgeCleared(name string) bool {
	switch name {
	case useraddress.EdgeOrderHistories:
		return m.clearedorder_histories
	case useraddress.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAddressMutation) ClearEdge(name string) error {
	switch name {
	case useraddress.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserAddress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAddressMutation) ResetEdge(name string) error {
	switch name {
	case useraddress.EdgeOrderHistories:
		m.ResetOrderHistories()
		return nil
	case useraddress.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserAddress edge %s", name)
}
