// Code generated by ent, DO NOT EDIT.

package ent

import (
	"product-server/ent/productinfo"
	"fmt"
	"strings"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

// ProductInfo is the model entity for the ProductInfo schema.
type ProductInfo struct {
	config `json:"-"`
	// ID of the ent.
	ID int32 `json:"sku,omitempty"`
	// Brand holds the value of the "brand" field.
	Brand string `json:"brand,omitempty"`
	// ProductName holds the value of the "productName" field.
	ProductName string `json:"productName,omitempty"`
	// ProductID holds the value of the "productId" field.
	ProductID string `json:"productId,omitempty"`
	// ShippingFee holds the value of the "shippingFee" field.
	ShippingFee int32 `json:"shippingFee,omitempty"`
	// Price holds the value of the "price" field.
	Price int32 `json:"price,omitempty"`
	// Intl holds the value of the "intl" field.
	Intl bool `json:"intl,omitempty"`
	// SearchInfo holds the value of the "searchInfo" field.
	SearchInfo string `json:"searchInfo,omitempty"`
	// Color holds the value of the "color" field.
	Color string `json:"color,omitempty"`
	// Category holds the value of the "category" field.
	Category string `json:"category,omitempty"`
	// CategorySpec holds the value of the "categorySpec" field.
	CategorySpec string `json:"categorySpec,omitempty"`
	// ImgType holds the value of the "imgType" field.
	ImgType string `json:"imgType,omitempty"`
	// PriceDescCursor holds the value of the "priceDescCursor" field.
	PriceDescCursor string `json:"priceDescCursor,omitempty"`
	// PriceAscCursor holds the value of the "priceAscCursor" field.
	PriceAscCursor string `json:"priceAscCursor,omitempty"`
	// Deploy holds the value of the "deploy" field.
	Deploy int32 `json:"deploy,omitempty"`
	// KorProductName holds the value of the "korProductName" field.
	KorProductName string `json:"korProductName,omitempty"`
	// KorBrand holds the value of the "korBrand" field.
	KorBrand string `json:"korBrand,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the ProductInfoQuery when eager-loading is set.
	Edges        ProductInfoEdges `json:"edges"`
	selectValues sql.SelectValues
}

// ProductInfoEdges holds the relations/edges for other nodes in the graph.
type ProductInfoEdges struct {
	// OrderRows holds the value of the order_rows edge.
	OrderRows []*OrderRow `json:"order_rows,omitempty"`
	// Sizes holds the value of the sizes edge.
	Sizes []*Size `json:"sizes,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// OrderRowsOrErr returns the OrderRows value or an error if the edge
// was not loaded in eager-loading.
func (e ProductInfoEdges) OrderRowsOrErr() ([]*OrderRow, error) {
	if e.loadedTypes[0] {
		return e.OrderRows, nil
	}
	return nil, &NotLoadedError{edge: "order_rows"}
}

// SizesOrErr returns the Sizes value or an error if the edge
// was not loaded in eager-loading.
func (e ProductInfoEdges) SizesOrErr() ([]*Size, error) {
	if e.loadedTypes[1] {
		return e.Sizes, nil
	}
	return nil, &NotLoadedError{edge: "sizes"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*ProductInfo) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case productinfo.FieldIntl:
			values[i] = new(sql.NullBool)
		case productinfo.FieldID, productinfo.FieldShippingFee, productinfo.FieldPrice, productinfo.FieldDeploy:
			values[i] = new(sql.NullInt64)
		case productinfo.FieldBrand, productinfo.FieldProductName, productinfo.FieldProductID, productinfo.FieldSearchInfo, productinfo.FieldColor, productinfo.FieldCategory, productinfo.FieldCategorySpec, productinfo.FieldImgType, productinfo.FieldPriceDescCursor, productinfo.FieldPriceAscCursor, productinfo.FieldKorProductName, productinfo.FieldKorBrand:
			values[i] = new(sql.NullString)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the ProductInfo fields.
func (pi *ProductInfo) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case productinfo.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field sku", value)
			}
			pi.ID = int32(value.Int64)
		case productinfo.FieldBrand:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field brand", values[i])
			} else if value.Valid {
				pi.Brand = value.String
			}
		case productinfo.FieldProductName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field productName", values[i])
			} else if value.Valid {
				pi.ProductName = value.String
			}
		case productinfo.FieldProductID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field productId", values[i])
			} else if value.Valid {
				pi.ProductID = value.String
			}
		case productinfo.FieldShippingFee:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field shippingFee", values[i])
			} else if value.Valid {
				pi.ShippingFee = int32(value.Int64)
			}
		case productinfo.FieldPrice:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field price", values[i])
			} else if value.Valid {
				pi.Price = int32(value.Int64)
			}
		case productinfo.FieldIntl:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field intl", values[i])
			} else if value.Valid {
				pi.Intl = value.Bool
			}
		case productinfo.FieldSearchInfo:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field searchInfo", values[i])
			} else if value.Valid {
				pi.SearchInfo = value.String
			}
		case productinfo.FieldColor:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field color", values[i])
			} else if value.Valid {
				pi.Color = value.String
			}
		case productinfo.FieldCategory:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field category", values[i])
			} else if value.Valid {
				pi.Category = value.String
			}
		case productinfo.FieldCategorySpec:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field categorySpec", values[i])
			} else if value.Valid {
				pi.CategorySpec = value.String
			}
		case productinfo.FieldImgType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field imgType", values[i])
			} else if value.Valid {
				pi.ImgType = value.String
			}
		case productinfo.FieldPriceDescCursor:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field priceDescCursor", values[i])
			} else if value.Valid {
				pi.PriceDescCursor = value.String
			}
		case productinfo.FieldPriceAscCursor:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field priceAscCursor", values[i])
			} else if value.Valid {
				pi.PriceAscCursor = value.String
			}
		case productinfo.FieldDeploy:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field deploy", values[i])
			} else if value.Valid {
				pi.Deploy = int32(value.Int64)
			}
		case productinfo.FieldKorProductName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field korProductName", values[i])
			} else if value.Valid {
				pi.KorProductName = value.String
			}
		case productinfo.FieldKorBrand:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field korBrand", values[i])
			} else if value.Valid {
				pi.KorBrand = value.String
			}
		default:
			pi.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the ProductInfo.
// This includes values selected through modifiers, order, etc.
func (pi *ProductInfo) Value(name string) (ent.Value, error) {
	return pi.selectValues.Get(name)
}

// QueryOrderRows queries the "order_rows" edge of the ProductInfo entity.
func (pi *ProductInfo) QueryOrderRows() *OrderRowQuery {
	return NewProductInfoClient(pi.config).QueryOrderRows(pi)
}

// QuerySizes queries the "sizes" edge of the ProductInfo entity.
func (pi *ProductInfo) QuerySizes() *SizeQuery {
	return NewProductInfoClient(pi.config).QuerySizes(pi)
}

// Update returns a builder for updating this ProductInfo.
// Note that you need to call ProductInfo.Unwrap() before calling this method if this ProductInfo
// was returned from a transaction, and the transaction was committed or rolled back.
func (pi *ProductInfo) Update() *ProductInfoUpdateOne {
	return NewProductInfoClient(pi.config).UpdateOne(pi)
}

// Unwrap unwraps the ProductInfo entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (pi *ProductInfo) Unwrap() *ProductInfo {
	_tx, ok := pi.config.driver.(*txDriver)
	if !ok {
		panic("ent: ProductInfo is not a transactional entity")
	}
	pi.config.driver = _tx.drv
	return pi
}

// String implements the fmt.Stringer.
func (pi *ProductInfo) String() string {
	var builder strings.Builder
	builder.WriteString("ProductInfo(")
	builder.WriteString(fmt.Sprintf("sku=%v, ", pi.ID))
	builder.WriteString("brand=")
	builder.WriteString(pi.Brand)
	builder.WriteString(", ")
	builder.WriteString("productName=")
	builder.WriteString(pi.ProductName)
	builder.WriteString(", ")
	builder.WriteString("productId=")
	builder.WriteString(pi.ProductID)
	builder.WriteString(", ")
	builder.WriteString("shippingFee=")
	builder.WriteString(fmt.Sprintf("%v", pi.ShippingFee))
	builder.WriteString(", ")
	builder.WriteString("price=")
	builder.WriteString(fmt.Sprintf("%v", pi.Price))
	builder.WriteString(", ")
	builder.WriteString("intl=")
	builder.WriteString(fmt.Sprintf("%v", pi.Intl))
	builder.WriteString(", ")
	builder.WriteString("searchInfo=")
	builder.WriteString(pi.SearchInfo)
	builder.WriteString(", ")
	builder.WriteString("color=")
	builder.WriteString(pi.Color)
	builder.WriteString(", ")
	builder.WriteString("category=")
	builder.WriteString(pi.Category)
	builder.WriteString(", ")
	builder.WriteString("categorySpec=")
	builder.WriteString(pi.CategorySpec)
	builder.WriteString(", ")
	builder.WriteString("imgType=")
	builder.WriteString(pi.ImgType)
	builder.WriteString(", ")
	builder.WriteString("priceDescCursor=")
	builder.WriteString(pi.PriceDescCursor)
	builder.WriteString(", ")
	builder.WriteString("priceAscCursor=")
	builder.WriteString(pi.PriceAscCursor)
	builder.WriteString(", ")
	builder.WriteString("deploy=")
	builder.WriteString(fmt.Sprintf("%v", pi.Deploy))
	builder.WriteString(", ")
	builder.WriteString("korProductName=")
	builder.WriteString(pi.KorProductName)
	builder.WriteString(", ")
	builder.WriteString("korBrand=")
	builder.WriteString(pi.KorBrand)
	builder.WriteByte(')')
	return builder.String()
}

// ProductInfos is a parsable slice of ProductInfo.
type ProductInfos []*ProductInfo
